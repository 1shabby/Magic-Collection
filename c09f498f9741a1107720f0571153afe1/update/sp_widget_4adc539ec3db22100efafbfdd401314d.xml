<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $window, $timeout,mtgCards) {
    var c = this;

    if (c.data.deck_name) {
        document.title = c.data.deck_name;
    }
    $scope.is_author = c.data.is_author;

    // Initialize model values
    $scope.layoutMode = 'columns'; // default layout
    $scope.groupBy = 'category'; // default group
    $scope.sortBy = 'alphabetical'; // default sort
    $scope.is_singleton = c.data.is_singleton; // Stores if it's a singleton deck
    $scope.format_name = c.data.format_name; // Stores the format name

    // Safely initialize card data
    $scope.all_cards = c.data.all_cards || [];

    function getCardType(card) {
        const line = (card.face_one.type_line || "").toLowerCase();
        const cleaned = line.replace(/legendary|basic|snow|token|tribal/g, '').trim();

        const priorities = [
            "creature", "planeswalker", "instant",
            "sorcery", "enchantment", "artifact",
            "battle", "land"
        ];

        for (let i = 0; i < priorities.length; i++) {
            if (cleaned.includes(priorities[i])) {
                return priorities[i];
            }
        }

        return "other";
    }

    function sortCards(cards) {
        if (!Array.isArray(cards)) return [];

        return cards.sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();

            if ($scope.sortBy === 'cmc') {
                const cmcA = parseFloat(a.cmc || 0);
                const cmcB = parseFloat(b.cmc || 0);
                if (cmcA !== cmcB) return cmcA - cmcB;
                return nameA.localeCompare(nameB);
            }

            if ($scope.sortBy === 'type') {
                const typeA = getCardType(a);
                const typeB = getCardType(b);
                if (typeA !== typeB) return typeA.localeCompare(typeB);
                return nameA.localeCompare(nameB);
            }

            if ($scope.sortBy === 'price') {
                const priceA = parseFloat(a.price || 0);
                const priceB = parseFloat(b.price || 0);
                if (priceA !== priceB) return priceA - priceB;
                return nameA.localeCompare(nameB);
            }

            // Default: alphabetical
            return nameA.localeCompare(nameB);
        });
    }

    $scope.groupCards = function() {
        if (!$scope.all_cards || !$scope.all_cards.length) {
            return;
        }

        const commander = [];
        const maybeboard = [];
        const sideboard = [];
        const otherCards = [];

        $scope.all_cards.forEach(card => {
            if (card.flags.is_commander) {
                commander.push(card);
            } else if (card.flags.is_maybeboard) {
                maybeboard.push(card);
            } else if (card.flags.is_sideboard) {
                sideboard.push(card);
            } else {
                otherCards.push(card);
            }
        });

        let groupMap = {};

        // Group by Category
        if ($scope.groupBy === 'category') {
            const original = c.data.categories || [];
            $scope.categories = original.map(cat => {
                const sortedCards = sortCards(angular.copy(cat.cards));
                return {
                    name: cat.name,
                    cards: sortedCards,
                    textLines: $scope.getTextLines(sortedCards)
                };
            });
            return;
        }


        // Group by Type
        if ($scope.groupBy === 'type') {
            otherCards.forEach(card => {
                const typeLine = (card.face_one.type_line || "").toLowerCase();
                const cleaned = typeLine.replace(/legendary|basic|snow|token|tribal/g, '').trim();

                const priorities = [{
                        type: "creature",
                        category: "Creature"
                    },
                    {
                        type: "planeswalker",
                        category: "Planeswalker"
                    },
                    {
                        type: "instant",
                        category: "Instant"
                    },
                    {
                        type: "sorcery",
                        category: "Sorcery"
                    },
                    {
                        type: "enchantment",
                        category: "Enchantment"
                    },
                    {
                        type: "artifact",
                        category: "Artifact"
                    },
                    {
                        type: "battle",
                        category: "Battle"
                    },
                    {
                        type: "land",
                        category: "Land"
                    }
                ];

                let matched = "Other";
                for (let i = 0; i < priorities.length; i++) {
                    if (cleaned.includes(priorities[i].type)) {
                        matched = priorities[i].category;
                        break;
                    }
                }

                if (!groupMap[matched]) groupMap[matched] = [];
                groupMap[matched].push(card);
            });
        }

        // Group by CMC
        if ($scope.groupBy === 'cmc') {
            otherCards.forEach(card => {
                const cmcValue = parseInt(card.cmc || 0, 10);
                const key = isNaN(cmcValue) ? "Unknown" : cmcValue.toString();

                if (!groupMap[key]) groupMap[key] = [];
                groupMap[key].push(card);
            });
        }

        // Convert groupMap to array
        const grouped = Object.keys(groupMap)
            .sort((a, b) => {
                const aNum = parseInt(a, 10);
                const bNum = parseInt(b, 10);
                return isNaN(aNum) || isNaN(bNum) ? a.localeCompare(b) : aNum - bNum;
            })
            .map(key => ({
                name: key,
                cards: sortCards(groupMap[key])
            }));

        // Commander / Sideboard / Maybeboard
        if (commander.length > 0) {
            grouped.unshift({
                name: "Commander",
                cards: sortCards(commander)
            });
        }
        if (maybeboard.length > 0) {
            grouped.push({
                name: "Maybeboard",
                cards: sortCards(maybeboard)
            });
        }
        if (sideboard.length > 0) {
            grouped.push({
                name: "Sideboard",
                cards: sortCards(sideboard)
            });
        }

        $scope.categories = grouped;
        $scope.categories.forEach(cat => {
            cat.textLines = $scope.getTextLines(cat.cards);
        });

    };

    // Watch for changes in groupBy and sortBy
    $scope.$watch('groupBy', function(newVal, oldVal) {
        if (newVal !== oldVal) {
            $scope.groupCards();
        }
    });

    $scope.$watch('sortBy', function(newVal, oldVal) {
        if (newVal !== oldVal) {
            $scope.groupCards();
        }
    });

    // Run initial grouping
    $timeout(function() {
        $scope.groupCards();
    });

    // Layout change hook
    $scope.onLayoutChange = function() {
    };

    $scope.setLayout = function(mode) {
        $scope.layoutMode = mode;
    };

    // Card flip
    $scope.flipCard = function(card) {
        card.flags.is_flipped = !card.flags.is_flipped;
    };

    // Quantity handlers
    $scope.incrementCard = function(card, event) {
        const newQty = parseInt(card.quantity || "0", 10) + 1;
        updateCardQuantity(card, newQty);
    };

    $scope.decrementCard = function(card, event) {
        const currentQty = parseInt(card.quantity || "0", 10);
        if (currentQty > 1) {
            const newQty = currentQty - 1;
            updateCardQuantity(card, newQty);
        }
    };

    function updateCardQuantity(card, newQuantity) {
        card.quantity = newQuantity;
        const payload = {
            card_sys_id: card.sys_id,
            new_quantity: newQuantity
        };
        c.server.get(payload).then(function(response) {
            if (response.success) {
                card.quantity = newQuantity;
                $scope.$applyAsync();
            }
        });
    }

    // Modal state
    $scope.modalCard = null;

    // Modal open/close handlers
    $scope.openCardModal = function(card, event) {
        //$scope.modalCard = card;
		mtgCards.setCard(card);
        if (event) event.stopPropagation();
    };

    $scope.closeCardModal = function(event) {
        $scope.modalCard = null;
        if (event) event.stopPropagation();
    };

    // Display helpers
    $scope.getCategoryQuantity = function(cat) {
        if (!cat || !cat.cards) return 0;
        return cat.cards.reduce((sum, c) => sum + (parseInt(c.quantity, 10) || 0), 0);
    };

    $scope.getCategoryPrice = function(cat) {
        if (!cat || !cat.cards) return 0;
        return cat.cards.reduce((sum, c) => {
            const price = parseFloat(c.price) || 0;
            const qty = parseInt(c.quantity, 10) || 0;
            return sum + price * qty;
        }, 0);
    };

    $scope.isCardIllegal = function(card, formatName) {
        if (!card) return false;

        const qty = parseInt(card.quantity, 10) || 1;
        const name = (card.name || "").toLowerCase();
        const oracleText = (card.face_one?.oracle_text || "").toLowerCase();
        const isBasicLand = ['plains', 'island', 'swamp', 'mountain', 'forest', 'wastes', 'snow-covered']
            .some(type => name.includes(type));

        const isUnlimitedQtyCard = oracleText.includes("a deck can have any number of cards");
        const sevenDwarves = oracleText.includes("A deck can have up to seven cards");

        if (card.legality[formatName] === false) {
            return true;
        }

        if (isUnlimitedQtyCard) {
            return false;
        }

        if (sevenDwarves) {
            if (qty <= 7) {
                return true;
            } else {
                return false;
            }
        }

        if ($scope.is_singleton) {
            if (!isBasicLand && qty > 1) {
                return true;
            }
        } else {
            if (!isBasicLand && qty > 4) {
                return true;
            }
        }

        return false;
    };

    $scope.getIllegalityReason = function(card, formatName) {
        if (!card) return "";

        const qty = parseInt(card.quantity, 10) || 1;
        const name = (card.name || "").toLowerCase();
        const oracleText = (card.face_one?.oracle_text || "").toLowerCase();
        const isBasicLand = ['plains', 'island', 'swamp', 'mountain', 'forest', 'wastes', 'snow-covered']
            .some(type => name.includes(type));
        const sevenDwarves = oracleText.includes("A deck can have up to seven cards");

        if (card.legality[formatName] === false) {
            return "This card is illegal in " + formatName + ".";
        }

        if (sevenDwarves && qty > 7) {
            return "A deck can have up to 7 copies of this card.";
        }

        if ($scope.is_singleton) {
            if (!isBasicLand && qty > 1) {
                return "Only one copy of a card is allowed in " + formatName + " (except basic lands).";
            }
        } else {
            if (!isBasicLand && qty > 4) {
                return "More than four copies are not allowed in " + formatName + ".";
            }
        }

        return "";
    };


    $scope.getCardTags = function(card) {
        const tags = [];
        if (card.flags.is_commander) tags.push("Commander");
        if (card.flags.is_maybeboard) tags.push("Maybeboard");
        if (card.flags.is_sideboard) tags.push("Sideboard");
        return tags.join(", ");
    };

    $scope.getTextLines = function(cards) {
        if (!cards || !cards.length) return "";
        return cards.map(card => {
            const card_qty = card.quantity;
            const card_name = card.name || "Unknown";
            // const card_cmc1 = card.face_one.mana_cost || 0;
            // const card_cmc2 = card.face_two.mana_cost;
            // const card_cmcStr = card_cmc2 !== undefined ? card_cmc1+'/'+card_cmc2 : card_cmc1;
            const card_cmc = card.cmc;
            const card_price = parseFloat(card.price || 0).toFixed(2);
            const line = card_qty + ' ' + card_name + ' ' + card_cmc + ' $' + card_price;
            return line;
        }).join("\n");
    };
};]]></client_script>
        <controller_as>c</controller_as>
        <css>.deck-container {&#13;
  display: flex;&#13;
  flex-wrap: nowrap; /* no wrapping */&#13;
  align-items: flex-start;&#13;
  padding: $double-space;&#13;
  gap: 2rem;&#13;
  width: 100%;&#13;
  overflow-x: auto;&#13;
  justify-content: space-between;&#13;
  background-color: $brand-primary;&#13;
  border-radius: $single-space;&#13;
  margin-top: $double-space;&#13;
  margin-bottom: 20px;&#13;
}&#13;
&#13;
.card-illegal {&#13;
  position: relative;&#13;
  border: 0.5rem solid #e53935 !important; /* red border */&#13;
  box-shadow: 0 0 10px rgba(229, 57, 53, 0.6);&#13;
}&#13;
&#13;
.card-illegal::after {&#13;
  content: attr(data-illegal-reason);&#13;
  display: block;&#13;
  background-color: rgba(200, 0, 0, 0.95);&#13;
  color: white;&#13;
  font-size: 14px;&#13;
  font-weight: bold;&#13;
  padding: 6px 8px;&#13;
  text-align: center;&#13;
  border-radius: 4px;&#13;
  position: absolute;&#13;
  bottom: 0;&#13;
  width: 100%;&#13;
  z-index: 50;&#13;
  white-space: normal;     &#13;
  overflow-wrap: break-word;&#13;
  line-height: 1.2;          &#13;
}&#13;
&#13;
/* Left side dynamic columns */&#13;
.deck-columns {&#13;
  display: grid;&#13;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Uniform column width */&#13;
  gap: 2rem; /* defined gap between dynamic columns */&#13;
  flex: 1 1 auto;&#13;
  min-width: 0;&#13;
}&#13;
&#13;
/* Right side fixed horizontal row of Maybeboard + Sideboard */&#13;
.deck-anchored-columns {&#13;
  display: flex;&#13;
  flex-direction: row;&#13;
  gap: 1rem; /* smaller gap between Maybeboard and Sideboard */&#13;
  flex: 0 0 auto;&#13;
  min-width: auto;&#13;
  max-width: none;&#13;
  justify-content: flex-end;&#13;
  margin-left: 1rem; /* reduce gap between last dynamic column and Maybeboard */&#13;
}&#13;
&#13;
/* Column Styling */&#13;
.deck-column {&#13;
  min-width: 250px; /* Same width for dynamic and anchored columns */&#13;
  max-width: 250px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  overflow: visible;&#13;
}&#13;
&#13;
.deck-column-header {&#13;
  font-weight: bold;&#13;
  font-size: 1.5rem;&#13;
  color: white;&#13;
  z-index: 10;&#13;
  margin-top: 1rem;&#13;
  padding-bottom: 1rem;&#13;
}&#13;
&#13;
/* Card Stack */&#13;
.card-stack {&#13;
  position: relative;&#13;
  width: 100%;&#13;
  overflow: hidden;&#13;
  z-index: 10;&#13;
}&#13;
&#13;
/* Stack Overlap */&#13;
.stacked-card {&#13;
  position: relative;&#13;
  margin-top: -33rem; /*controls how tightly stacked they are in the column*/&#13;
  transition: transform 0.5s ease;&#13;
  z-index: 1;&#13;
}&#13;
&#13;
/* Top card and single-card columns shouldn't overlap */&#13;
.stacked-card:first-child {&#13;
  margin-top: 0;&#13;
}&#13;
&#13;
/* Prevent shifting on hover if it's the only card */&#13;
.card-stack:only-child .stacked-card:hover {&#13;
  transform: none !important;&#13;
}&#13;
&#13;
/* Only shift hovered card forward */&#13;
.stacked-card:hover {&#13;
  z-index: 999 !important;&#13;
}&#13;
&#13;
/* Move only the cards *after* the hovered one downward */&#13;
.stacked-card:hover ~ .stacked-card {&#13;
  transform: translateY(35rem);&#13;
  z-index: -999 !important; /* Moves cards below the card stack z-index */&#13;
}&#13;
&#13;
/* Unified Image Container */&#13;
.image-container {&#13;
  position: relative;&#13;
  perspective: 1000px;&#13;
  max-width: 250px;       /* unified max width */&#13;
  width: 100%;&#13;
  aspect-ratio: 2.5 / 3.5; /* consistent aspect ratio */&#13;
  border-radius: 5%;&#13;
  overflow: hidden;&#13;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);&#13;
}&#13;
&#13;
/* Image */&#13;
.image {&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  object-fit: cover; /* Ensure image covers container */&#13;
  border-radius: 5%;&#13;
  display: block;&#13;
}&#13;
&#13;
/* Button styling for cards */&#13;
.card-button {&#13;
  width: 100%;&#13;
  max-width: 250px;&#13;
  background: none;&#13;
  border: none;&#13;
  padding: 0;&#13;
  cursor: pointer;&#13;
  outline: none;&#13;
  display: block;&#13;
  transition: transform 0.5s ease;&#13;
}&#13;
&#13;
/* Focus style for accessibility */&#13;
.card-button:focus {&#13;
  outline: 3px solid #00aaff;&#13;
  outline-offset: 3px;&#13;
}&#13;
&#13;
.column-count {&#13;
  font-weight: normal;&#13;
  font-size: 1rem;&#13;
  color: #ccc;&#13;
  margin-left: 0.4rem;&#13;
}&#13;
&#13;
.quantity-tag {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  left: 0;&#13;
  width: 45px;&#13;
  height: 45px;&#13;
  background-color: rgba(101, 101, 101, 0.9); /* semi-transparent dark background */&#13;
  color: white;                        &#13;
  font-size: 16px;&#13;
  font-weight: bold;&#13;
  display: flex;&#13;
  align-items: flex-start;&#13;
  justify-content: flex-start;&#13;
  padding: 4px;&#13;
  clip-path: polygon(0 0, 100% 0, 0 100%);&#13;
  z-index: 20;&#13;
  pointer-events: none;&#13;
}&#13;
&#13;
.quantity-tag span {&#13;
  position: absolute;&#13;
  top: -30px;&#13;
  left: 5px;&#13;
  font-size: 0.65rem;&#13;
  font-weight: bold;&#13;
  color: white;&#13;
  white-space: nowrap;&#13;
  pointer-events: none;&#13;
}&#13;
&#13;
.game-changer-tag {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  right: 0;&#13;
  width: 45px;&#13;
  height: 45px;&#13;
  background-color: rgba(255, 165, 0, 0.9); /* Orange/gold tone */&#13;
  color: white;&#13;
  font-size: 18px;&#13;
  font-weight: bold;&#13;
  display: flex;&#13;
  align-items: flex-start;&#13;
  justify-content: flex-end;&#13;
  padding: 4px;&#13;
  clip-path: polygon(100% 0, 0 0, 100% 100%);&#13;
  z-index: 20;&#13;
  pointer-events: none;&#13;
  text-shadow: 1px 1px 2px black;&#13;
}&#13;
&#13;
.game-changer-icon {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  right: 0;&#13;
  width: 20px;&#13;
  height: 20px;&#13;
  object-fit: cover;&#13;
  margin-top: 5px;&#13;
  margin-right: 5px;&#13;
}&#13;
&#13;
.foil-overlay {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  left: 0;&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  pointer-events: none;&#13;
  opacity: 0.7;&#13;
  border-radius: 10px;&#13;
}&#13;
&#13;
.card-flipper {&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  position: relative;&#13;
  transition: transform 0.6s;&#13;
  transform-style: preserve-3d;&#13;
}&#13;
&#13;
.card-face {&#13;
  backface-visibility: hidden;&#13;
  position: absolute;&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  border-radius: 5%;&#13;
  top: 0;&#13;
  left: 0;&#13;
}&#13;
&#13;
.front-face {&#13;
  z-index: 2;&#13;
}&#13;
&#13;
.back-face {&#13;
  transform: rotateY(180deg);&#13;
}&#13;
&#13;
.hover-buttons {&#13;
  position: absolute;&#13;
  top: 4.5rem;&#13;
  right: 0px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  z-index: 30;&#13;
}&#13;
&#13;
.hover-btn {&#13;
  background-color: rgba(249,250,251,.05);&#13;
  border: 2px solid hsla(0,0%,100%,.5);&#13;
  width: 5rem;&#13;
  height: 5rem;&#13;
  font-size: 3.5rem;&#13;
  font-weight: bolder;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
  transition: background-color .2s ease-in-out;&#13;
  padding: 0;&#13;
  line-height: 1;&#13;
  text-align: center;&#13;
}&#13;
&#13;
.hover-btn.flip {&#13;
  position: absolute;&#13;
  left: -20rem;&#13;
}&#13;
&#13;
.hover-btn.card-modal {&#13;
  background-color: rgba(249,250,251,.05);&#13;
  border: 2px solid hsla(0,0%,100%,.5);&#13;
  font-size: 3.5rem;&#13;
  font-weight: bolder;&#13;
  width: 5rem;&#13;
  height: 5rem;&#13;
  z-index: 30;&#13;
}&#13;
&#13;
.hover-btn.minus {&#13;
  margin-bottom:1rem; &#13;
}&#13;
&#13;
.hover-btn:hover {&#13;
  background-color: rgba(249,250,251,.3);&#13;
}&#13;
&#13;
.price-info {&#13;
  display:flex;&#13;
  justify-content:center;&#13;
}&#13;
&#13;
/* Hide back-face by default */&#13;
.image-container .back-face {&#13;
  display: none;&#13;
}&#13;
&#13;
/* Show/hide faces on flip */&#13;
.image-container.flipped .front-face {&#13;
  display: none;&#13;
}&#13;
&#13;
.image-container.flipped .back-face {&#13;
  display: block;&#13;
  transform: rotateY(0deg);&#13;
}&#13;
&#13;
.category-meta-row{&#13;
  display:flex;&#13;
  justify-content: space-between;&#13;
  font-weight:normal;&#13;
  font-size:1.2rem;&#13;
}&#13;
&#13;
.deck-controls {&#13;
  justify-content:center;&#13;
}&#13;
&#13;
.form-group label {&#13;
  font-weight:bold; &#13;
}&#13;
&#13;
.form-control {&#13;
  background-color:$brand-primary;&#13;
  color:white;&#13;
  border-color:$brand-secondary;&#13;
}&#13;
&#13;
/*Grid Layout*/&#13;
.card-grid {&#13;
  display: grid;&#13;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* match columns */&#13;
  gap: 2rem; /* match columns */&#13;
}&#13;
&#13;
/* Grid card uses full width with max 250px */&#13;
.grid-card {&#13;
  position: relative;&#13;
  width: 100%;&#13;
  max-width: 250px;&#13;
}&#13;
&#13;
.deck-grid {&#13;
  width:100%;&#13;
}&#13;
/*Text View*/&#13;
.deck-text-view .text-deck-container {&#13;
  display: flex;&#13;
  flex-wrap: wrap;&#13;
  align-items: flex-start;&#13;
  background-color: $brand-primary;&#13;
  border-radius: 5px;&#13;
  justify-content:center;&#13;
}&#13;
&#13;
.deck-text-view .text-category {&#13;
  font-family: monospace;&#13;
  white-space: pre;&#13;
}&#13;
&#13;
.deck-text-view .category-title {&#13;
  font-weight: bold;&#13;
  margin-bottom: 0.25rem;&#13;
}&#13;
&#13;
.text-card-list {&#13;
  color: $brand-tertiary;&#13;
  padding: 0.5rem;&#13;
  border-radius: 4px;&#13;
  background-color:transparent;&#13;
  border:none;&#13;
}&#13;
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>false</has_preview>
        <id>mtg_deck_view</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck View</name>
        <option_schema/>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
    // --- Quantity Update Handler ---
    if (input && input.card_sys_id && input.new_quantity !== undefined) {
        var updateGR = new GlideRecord("x_759224_magic_c_0_deck_card");
        if (updateGR.get(input.card_sys_id)) {
            updateGR.quantity = input.new_quantity;
            updateGR.update();
            data.success = true;
        } else {
            data.success = false;
            data.message = "Deck card not found.";
        }
        return;
    }

    // --- Regular Deck Loading Logic ---
    var deckId = (typeof input !== 'undefined' && input.deck_id) ? input.deck_id : $sp.getParameter("deck_id");
    data.categories = [];
    data.all_cards = [];
    data.deck_sys_id = deckId;

    if (!deckId) {
        data.error = "Missing deck_id";
        return;
    }

    var deckGR = new GlideRecord('x_759224_magic_c_0_mtg_deck');
    deckGR.addQuery('sys_id', deckId);
    deckGR.query();

    if (!deckGR.next()) {
        data.error = "Deck not found";
        return;
    }

    var formatGR = deckGR.getValue('format') ? new GlideRecord('x_759224_magic_c_0_deck_formats') : null;
    var formatName = '';
    var isSingleton = false;

    if (formatGR && formatGR.get(deckGR.getValue('format'))) {
        formatName = formatGR.getValue('name');
        isSingleton = formatGR.getValue('is_singleton') == '1';
    }

    data.format_name = formatName.toLowerCase();
    data.is_singleton = isSingleton;


    data.deck_name = deckGR.getValue('name');
    var authors = deckGR.getValue("author");
    data.is_author = authors.indexOf(gs.getUserID()) !== -1;

    var magicUtils = new x_759224_magic_c_0.magic_utils();

    var deckCardGR = new GlideRecord("x_759224_magic_c_0_deck_card");
    deckCardGR.addQuery("deck", deckId);
    deckCardGR.query();

    var categoryMap = {};
    var allCards = [];

    while (deckCardGR.next()) {
        var cardData = magicUtils.getCardData(deckCardGR.getValue('card'));
        cardData.flags.is_commander = deckCardGR.getValue("is_commander") == "1";
        cardData.flags.is_maybeboard = deckCardGR.getValue("is_maybeboard") == "1";
        cardData.flags.is_sideboard = deckCardGR.getValue("is_sideboard") == "1";
        cardData.quantity = deckCardGR.getValue('quantity');
        cardData.sys_id = deckCardGR.getUniqueValue();

        let category = "";
        if (cardData.flags.is_commander) {
            category = "Commander";
        } else {
            var notes = deckCardGR.getValue("notes") || "";
            var trimmedNote = notes.trim();
            if (trimmedNote) {
                var tags = trimmedNote.split(",");
                if (tags.length && tags[0].trim()) {
                    category = tags[0].trim();
                }
            }
            if (!category) {
                if (cardData.is_maybeboard) {
                    category = "Maybeboard";
                } else if (cardData.is_sideboard) {
                    category = "Sideboard";
                }
            }
            if (!category) {
                var typeLine = (cardData.face_one.type_line || "").toLowerCase();
                typeLine = typeLine.replace(/legendary|basic|snow|token|tribal/g, '').trim();
                var typePriority = [{
                        type: "creature",
                        category: "Creature"
                    },
                    {
                        type: "planeswalker",
                        category: "Planeswalker"
                    },
                    {
                        type: "instant",
                        category: "Instant"
                    },
                    {
                        type: "sorcery",
                        category: "Sorcery"
                    },
                    {
                        type: "enchantment",
                        category: "Enchantment"
                    },
                    {
                        type: "artifact",
                        category: "Artifact"
                    },
                    {
                        type: "battle",
                        category: "Battle"
                    },
                    {
                        type: "land",
                        category: "Land"
                    }
                ];
                for (var i = 0; i < typePriority.length; i++) {
                    if (typeLine.indexOf(typePriority[i].type) !== -1) {
                        category = typePriority[i].category;
                        break;
                    }
                }
                if (!category) {
                    category = "Other";
                }
            }
        }
        if (!categoryMap[category]) {
            categoryMap[category] = [];
        }
        categoryMap[category].push(cardData);
        allCards.push(cardData);
    }

    // Sort cards within each category
    var orderedCategories = [];
    var commanderFirst = categoryMap["Commander"] ? ["Commander"] : [];
    // Custom ordering: Commander, (alphabetical others), Maybeboard, Sideboard
    var maybeboard = categoryMap["Maybeboard"] ? ["Maybeboard"] : [];
    var sideboard = categoryMap["Sideboard"] ? ["Sideboard"] : [];
    var rest = Object.keys(categoryMap)
        .filter(function(k) {
            return k !== "Commander" && k !== "Maybeboard" && k !== "Sideboard";
        })
        .sort(function(a, b) {
            return categoryMap[a].length - categoryMap[b].length;
        });
    var allKeys = commanderFirst.concat(rest, maybeboard, sideboard);
    allKeys.forEach(function(key) {
        orderedCategories.push({
            name: key,
            cards: categoryMap[key]
        });
    });
    data.categories = orderedCategories;
    data.all_cards = allCards;
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 02:06:20</sys_created_on>
        <sys_id>4adc539ec3db22100efafbfdd401314d</sys_id>
        <sys_mod_count>287</sys_mod_count>
        <sys_name>MTG Deck View</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_4adc539ec3db22100efafbfdd401314d</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-22 19:17:30</sys_updated_on>
        <template><![CDATA[<div class="deck-controls" style="display: flex; gap: 2rem; align-items: flex-end; margin-bottom: 1rem;">
  <!-- Display As -->
  <div class="form-group">
    <label for="displayAs">Display As</label>
    <select id="displayAs" class="form-control" ng-model="layoutMode" ng-change="onLayoutChange()">
      <option value="columns">Columns</option>
      <option value="grid">Grid</option>
      <option value="text">Text</option>
    </select>
  </div>

  <!-- Group By -->
  <div class="form-group">
    <label for="groupBy">Group By</label>
    <select id="groupBy" class="form-control" ng-model="groupBy">
      <option value="category">Categories</option>
      <option value="type">Type</option>
      <option value="cmc">CMC</option>
    </select>
  </div>

  <!-- Sort By -->
  <div class="form-group">
    <label for="sortBy">Sort By</label>
    <select id="sortBy" class="form-control" ng-model="sortBy">
      <option value="alphabetical">Alphabetical</option>
      <option value="cmc">CMC</option>
      <option value="type">Type</option>
      <option value="price">Price</option>
    </select>
  </div>
</div>

<div class="deck-container" ng-if="layoutMode === 'columns'">
  <div class="deck-columns">
    <div class="deck-column" ng-repeat="cat in categories track by cat.name" ng-if="cat.name !== 'Maybeboard' && cat.name !== 'Sideboard'">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> <!-- placeholder for future actions/menu --> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container"
               ng-class="{
                         'flipped': card.flags.is_flipped,
                         'card-illegal': isCardIllegal(card,format_name)
                         }"
               data-illegal-reason="{{ isCardIllegal(card,format_name) ? getIllegalityReason(card,format_name) : '' }}">

            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="deck-anchored-columns">
    <div class="deck-column" ng-repeat="cat in categories track by cat.name" ng-if="cat.name === 'Maybeboard'">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> <!-- placeholder for future actions/menu --> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container"
               ng-class="{
                         'flipped': card.flags.is_flipped,
                         'card-illegal': isCardIllegal(card,format_name)
                         }"
               data-illegal-reason="{{ isCardIllegal(card,format_name) ? getIllegalityReason(card,format_name) : '' }}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="deck-column" ng-repeat="cat in categories track by cat.name" ng-if="cat.name === 'Sideboard'">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> <!-- placeholder for future actions/menu --> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container"
               ng-class="{
                         'flipped': card.flags.is_flipped,
                         'card-illegal': isCardIllegal(card,format_name)
                         }"
               data-illegal-reason="{{ isCardIllegal(card,format_name) ? getIllegalityReason(card,format_name) : '' }}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="deck-container" ng-if="layoutMode === 'grid'">
  <div class="deck-grid">
    <div class="deck-grid-category" ng-repeat="cat in categories track by cat.name">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"></span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>

      <!-- Grid of cards -->
      <div class="card-grid">
        <div class="grid-card" ng-repeat="card in cat.cards track by card.sys_id">
          <div class="image-container"
               ng-class="{
                         'flipped': card.flags.is_flipped,
                         'card-illegal': isCardIllegal(card,format_name)
                         }"
               data-illegal-reason="{{ isCardIllegal(card,format_name) ? getIllegalityReason(card, format_name) : '' }}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src="x_759224_magic_c_0.game_changer_diamond.png" class="game-changer-icon" />
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil" />
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="deck-text-view" ng-if="layoutMode === 'text'">
  <div class="text-deck-container">
    <div class="text-category" 
         ng-repeat="cat in categories track by cat.name"
         ng-style="{'min-width': '250px', 'margin-right': '2rem', 'display': 'inline-block', 'vertical-align': 'top'}">
      <h4 class="category-title">
        <!-- Use mana pip when grouped by CMC and header is numeric -->
        <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
             ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
             alt="{{ cat.name }}"
             style="height: 24px; vertical-align: middle;" />

        <!-- Fallback to name (for non-CMC headers like "Unknown") -->
        <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
      </h4>
      <div class="category-meta-row">
        <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span> |
        <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
      </div>
      <pre class="text-card-list">{{ cat.textLines }}</pre>
    </div>
  </div>
</div>

<!-- Card Modal -->
<div class="modal-backdrop" ng-if="modalCard" ng-click="closeCardModal($event)" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:1000;"></div>
<div class="card-modal-window" ng-if="modalCard" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#222;color:white;z-index:1001;padding:2rem;border-radius:12px;max-width:90vw;max-height:90vh;overflow:auto;box-shadow:0 8px 32px rgba(0,0,0,0.5);">
  <button style="position:absolute;top:1rem;right:1rem;font-size:2rem;background:none;border:none;color:white;cursor:pointer;z-index:1100;" ng-click="closeCardModal($event)">&times;</button>
  <div ng-if="modalCard">
    <div style="display:flex;gap:2rem;align-items:flex-start;">
      <img ng-src="{{modalCard.face_one.image}}" alt="{{modalCard.name}}" style="width:250px;max-width:40vw;border-radius:8px;box-shadow:0 2px 8px #000;">
      <div style="flex:1;min-width:200px;">
        <h2 style="margin-top:0;">{{modalCard.name}}</h2>
        <div><b>Type:</b> {{modalCard.face_one.type_line}}</div>
        <div ng-if="modalCard.face_one.oracle_text"><b>Text:</b> <span style="white-space:pre-line;">{{modalCard.face_one.oracle_text}}</span></div>
        <div ng-if="modalCard.face_two && modalCard.face_two.name">
          <hr>
          <h3>{{modalCard.face_two.name}}</h3>
          <div><b>Type:</b> {{modalCard.face_two.type_line}}</div>
          <div ng-if="modalCard.face_two.oracle_text"><b>Text:</b> <span style="white-space:pre-line;">{{modalCard.face_two.oracle_text}}</span></div>
        </div>
        <div style="margin-top:1rem;">
          <b>Quantity:</b> {{modalCard.quantity}}<br>
          <b>CMC:</b> {{modalCard.cmc}}<br>
          <b>Price:</b> ${{modalCard.price | number:2}}<br>
          <b>Tags:</b> {{getCardTags(modalCard)}}
        </div>
        <div style="margin-top:1rem;" ng-if="modalCard.legality">
          <b>Legality:</b>
          <ul>
            <li ng-repeat="(fmt, legal) in modalCard.legality">{{fmt}}: <span ng-if="legal">Legal</span><span ng-if="!legal">Illegal</span></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
