<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $window, $timeout) {
    var c = this;

    if (c.data.deck_name) {
        document.title = c.data.deck_name;
    }

    // Initialize model values
    $scope.layoutMode = 'columns'; // default layout
    $scope.groupBy = 'category'; // default group
    $scope.sortBy = 'alphabetical'; // default sort

    // Safely initialize card data
    $scope.all_cards = c.data.all_cards || [];

    function getCardType(card) {
        const line = (card.face_one.type_line || "").toLowerCase();
        const cleaned = line.replace(/legendary|basic|snow|token|tribal/g, '').trim();

        const priorities = [
            "creature", "planeswalker", "instant",
            "sorcery", "enchantment", "artifact",
            "battle", "land"
        ];

        for (let i = 0; i < priorities.length; i++) {
            if (cleaned.includes(priorities[i])) {
                return priorities[i];
            }
        }

        return "other";
    }

    function sortCards(cards) {
        if (!Array.isArray(cards)) return [];

        return cards.sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();

            if ($scope.sortBy === 'cmc') {
                const cmcA = parseFloat(a.cmc || 0);
                const cmcB = parseFloat(b.cmc || 0);
                if (cmcA !== cmcB) return cmcA - cmcB;
                return nameA.localeCompare(nameB);
            }

            if ($scope.sortBy === 'type') {
                const typeA = getCardType(a);
                const typeB = getCardType(b);
                if (typeA !== typeB) return typeA.localeCompare(typeB);
                return nameA.localeCompare(nameB);
            }

            if ($scope.sortBy === 'price') {
                const priceA = parseFloat(a.price || 0);
                const priceB = parseFloat(b.price || 0);
                if (priceA !== priceB) return priceA - priceB;
                return nameA.localeCompare(nameB);
            }

            // Default: alphabetical
            return nameA.localeCompare(nameB);
        });
    }

    $scope.groupCards = function() {
        if (!$scope.all_cards || !$scope.all_cards.length) {
            return;
        }

        const commander = [];
        const maybeboard = [];
        const sideboard = [];
        const otherCards = [];

        $scope.all_cards.forEach(card => {
            if (card.flags.is_commander) {
                commander.push(card);
            } else if (card.flags.is_maybeboard) {
                maybeboard.push(card);
            } else if (card.flags.is_sideboard) {
                sideboard.push(card);
            } else {
                otherCards.push(card);
            }
        });

        let groupMap = {};

        // Group by Category
        if ($scope.groupBy === 'category') {
            const original = c.data.categories || [];
            // Deep copy and sort each category's cards
            $scope.categories = original.map(cat => {
                return {
                    name: cat.name,
                    cards: sortCards(angular.copy(cat.cards))
                };
            });
            return;
        }

        // Group by Type
        if ($scope.groupBy === 'type') {
            otherCards.forEach(card => {
                const typeLine = (card.face_one.type_line || "").toLowerCase();
                const cleaned = typeLine.replace(/legendary|basic|snow|token|tribal/g, '').trim();

                const priorities = [{
                        type: "creature",
                        category: "Creature"
                    },
                    {
                        type: "planeswalker",
                        category: "Planeswalker"
                    },
                    {
                        type: "instant",
                        category: "Instant"
                    },
                    {
                        type: "sorcery",
                        category: "Sorcery"
                    },
                    {
                        type: "enchantment",
                        category: "Enchantment"
                    },
                    {
                        type: "artifact",
                        category: "Artifact"
                    },
                    {
                        type: "battle",
                        category: "Battle"
                    },
                    {
                        type: "land",
                        category: "Land"
                    }
                ];

                let matched = "Other";
                for (let i = 0; i < priorities.length; i++) {
                    if (cleaned.includes(priorities[i].type)) {
                        matched = priorities[i].category;
                        break;
                    }
                }

                if (!groupMap[matched]) groupMap[matched] = [];
                groupMap[matched].push(card);
            });
        }

        // Group by CMC
        if ($scope.groupBy === 'cmc') {
            otherCards.forEach(card => {
                const cmcValue = parseInt(card.cmc || 0, 10);
                const key = isNaN(cmcValue) ? "Unknown" : cmcValue.toString();

                if (!groupMap[key]) groupMap[key] = [];
                groupMap[key].push(card);
            });
        }

        // Convert groupMap to array
        const grouped = Object.keys(groupMap)
            .sort((a, b) => {
                const aNum = parseInt(a, 10);
                const bNum = parseInt(b, 10);
                return isNaN(aNum) || isNaN(bNum) ? a.localeCompare(b) : aNum - bNum;
            })
            .map(key => ({
                name: key,
                cards: sortCards(groupMap[key])
            }));

        // Commander / Sideboard / Maybeboard
        if (commander.length > 0) {
            grouped.unshift({
                name: "Commander",
                cards: sortCards(commander)
            });
        }
        if (maybeboard.length > 0) {
            grouped.push({
                name: "Maybeboard",
                cards: sortCards(maybeboard)
            });
        }
        if (sideboard.length > 0) {
            grouped.push({
                name: "Sideboard",
                cards: sortCards(sideboard)
            });
        }

        $scope.categories = grouped;
    };

    // Watch for changes in groupBy and sortBy
    $scope.$watch('groupBy', function(newVal, oldVal) {
        if (newVal !== oldVal) {
            $scope.groupCards();
        }
    });

    $scope.$watch('sortBy', function(newVal, oldVal) {
        if (newVal !== oldVal) {
            $scope.groupCards();
        }
    });

    // Run initial grouping
    $timeout(function() {
        $scope.groupCards();
    });

    // Layout change hook
    $scope.onLayoutChange = function() {
        console.log("Layout changed to:", $scope.layoutMode);
    };

    $scope.setLayout = function(mode) {
        $scope.layoutMode = mode;
    };

    // Card flip
    $scope.flipCard = function(card) {
        card.flags.is_flipped = !card.flags.is_flipped;
    };

    // Quantity handlers
    $scope.incrementCard = function(card, event) {
        const newQty = parseInt(card.quantity || "0", 10) + 1;
        updateCardQuantity(card, newQty);
    };

    $scope.decrementCard = function(card, event) {
        const currentQty = parseInt(card.quantity || "0", 10);
        if (currentQty > 1) {
            const newQty = currentQty - 1;
            updateCardQuantity(card, newQty);
        }
    };

    function updateCardQuantity(card, newQuantity) {
        card.quantity = newQuantity;
        const payload = {
            card_sys_id: card.sys_id,
            new_quantity: newQuantity
        };
        c.server.get(payload).then(function(response) {
            if (response.success) {
                card.quantity = newQuantity;
                $scope.$applyAsync();
            }
        });
    }

    // Optional modal
    $scope.openCardModal = function(card, event) {
        alert('Card modal for: ' + card.name);
    };

    // Display helpers
    $scope.getCategoryQuantity = function(cat) {
        if (!cat || !cat.cards) return 0;
        return cat.cards.reduce((sum, c) => sum + (parseInt(c.quantity, 10) || 0), 0);
    };

    $scope.getCategoryPrice = function(cat) {
        if (!cat || !cat.cards) return 0;
        return cat.cards.reduce((sum, c) => {
            const price = parseFloat(c.price) || 0;
            const qty = parseInt(c.quantity, 10) || 0;
            return sum + price * qty;
        }, 0);
    };

    $scope.getCardTags = function(card) {
        const tags = [];
        if (card.flags.is_commander) tags.push("Commander");
        if (card.flags.is_maybeboard) tags.push("Maybeboard");
        if (card.flags.is_sideboard) tags.push("Sideboard");
        return tags.join(", ");
    };
};]]></client_script>
        <controller_as>c</controller_as>
        <css>.deck-container {&#13;
  display: flex;&#13;
  flex-wrap: nowrap; /* no wrapping */&#13;
  align-items: flex-start;&#13;
  padding: $double-space;&#13;
  gap: 2rem;&#13;
  width: 100%;&#13;
  overflow-x: auto;&#13;
  justify-content: space-between;&#13;
  background-color: $brand-primary;&#13;
  border-radius: $single-space;&#13;
  margin-top: $double-space;&#13;
  margin-bottom: 20px;&#13;
}&#13;
&#13;
/* Left side dynamic columns */&#13;
.deck-columns {&#13;
  display: grid;&#13;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Uniform column width */&#13;
  gap: 2rem; /* defined gap between dynamic columns */&#13;
  flex: 1 1 auto;&#13;
  min-width: 0;&#13;
}&#13;
&#13;
/* Right side fixed horizontal row of Maybeboard + Sideboard */&#13;
.deck-anchored-columns {&#13;
  display: flex;&#13;
  flex-direction: row;&#13;
  gap: 1rem; /* smaller gap between Maybeboard and Sideboard */&#13;
  flex: 0 0 auto;&#13;
  min-width: auto;&#13;
  max-width: none;&#13;
  justify-content: flex-end;&#13;
  margin-left: 1rem; /* reduce gap between last dynamic column and Maybeboard */&#13;
}&#13;
&#13;
/* Column Styling */&#13;
.deck-column {&#13;
  min-width: 250px; /* Same width for dynamic and anchored columns */&#13;
  max-width: 250px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  overflow: visible;&#13;
}&#13;
&#13;
.deck-column-header {&#13;
  font-weight: bold;&#13;
  font-size: 1.5rem;&#13;
  color: white;&#13;
  z-index: 10;&#13;
  margin-top: 1rem;&#13;
  padding-bottom: 1rem;&#13;
}&#13;
&#13;
/* Card Stack */&#13;
.card-stack {&#13;
  position: relative;&#13;
  width: 100%;&#13;
  overflow: hidden;&#13;
  z-index: 10;&#13;
}&#13;
&#13;
/* Stack Overlap */&#13;
.stacked-card {&#13;
  position: relative;&#13;
  margin-top: -33rem; /*controls how tightly stacked they are in the column*/&#13;
  transition: transform 0.5s ease;&#13;
  z-index: 1;&#13;
}&#13;
&#13;
/* Top card and single-card columns shouldn't overlap */&#13;
.stacked-card:first-child {&#13;
  margin-top: 0;&#13;
}&#13;
&#13;
/* Prevent shifting on hover if it's the only card */&#13;
.card-stack:only-child .stacked-card:hover {&#13;
  transform: none !important;&#13;
}&#13;
&#13;
/* Only shift hovered card forward */&#13;
.stacked-card:hover {&#13;
  z-index: 999 !important;&#13;
}&#13;
&#13;
/* Move only the cards *after* the hovered one downward */&#13;
.stacked-card:hover ~ .stacked-card {&#13;
  transform: translateY(35rem);&#13;
  z-index: -999 !important /* Moves cards below the card stack z-index*/&#13;
}&#13;
&#13;
.image-container {&#13;
  position: relative;&#13;
  perspective:1000px;&#13;
  max-width: 250px;&#13;
  width: 100%;&#13;
  border-radius: 5%;&#13;
  overflow: hidden;&#13;
  /*box-shadow: 0 4px 8px rgba(0,0,0,0.3); */&#13;
}&#13;
&#13;
&#13;
/* Image */&#13;
.image {&#13;
  width: 100%;&#13;
  border-radius: 5%;&#13;
  display: block;&#13;
}&#13;
&#13;
/* Button styling for cards */&#13;
.card-button {&#13;
  width: 100%;&#13;
  max-width: 250px;&#13;
  background: none;&#13;
  border: none;&#13;
  padding: 0;&#13;
  cursor: pointer;&#13;
  outline: none;&#13;
  display: block;&#13;
  transition: transform 0.5s ease;&#13;
}&#13;
&#13;
/* Focus style for accessibility */&#13;
.card-button:focus {&#13;
  outline: 3px solid #00aaff;&#13;
  outline-offset: 3px;&#13;
}&#13;
&#13;
.column-count {&#13;
  font-weight: normal;&#13;
  font-size: 1rem;&#13;
  color: #ccc;&#13;
  margin-left: 0.4rem;&#13;
}&#13;
&#13;
.quantity-tag {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  left: 0;&#13;
  width: 45px;&#13;
  height: 45px;&#13;
  background-color: rgba(101, 101, 101, 0.9); /* semi-transparent dark background */&#13;
  color: white;                        &#13;
  font-size: 16px;&#13;
  font-weight: bold;&#13;
  display: flex;&#13;
  align-items: flex-start;&#13;
  justify-content: flex-start;&#13;
  padding: 4px;&#13;
  clip-path: polygon(0 0, 100% 0, 0 100%);&#13;
  z-index: 20;&#13;
  pointer-events: none;&#13;
}&#13;
&#13;
.quantity-tag span {&#13;
  position: absolute;&#13;
  top: -30px;&#13;
  left: 5px;&#13;
  font-size: 0.65rem;&#13;
  font-weight: bold;&#13;
  color: white;&#13;
  white-space: nowrap;&#13;
  pointer-events: none;&#13;
}&#13;
&#13;
.game-changer-tag {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  right: 0;&#13;
  width: 45px;&#13;
  height: 45px;&#13;
  background-color: rgba(255, 165, 0, 0.9); /* Orange/gold tone */&#13;
  color: white;&#13;
  font-size: 18px;&#13;
  font-weight: bold;&#13;
  display: flex;&#13;
  align-items: flex-start;&#13;
  justify-content: flex-end;&#13;
  padding: 4px;&#13;
  clip-path: polygon(100% 0, 0 0, 100% 100%);&#13;
  z-index: 20;&#13;
  pointer-events: none;&#13;
  text-shadow: 1px 1px 2px black;&#13;
}&#13;
&#13;
.game-changer-icon {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  right: 0;&#13;
  width: 20px;&#13;
  height: 20px;&#13;
  object-fit: cover;&#13;
  margin-top: 5px;&#13;
  margin-right: 5px;&#13;
}&#13;
&#13;
.foil-overlay {&#13;
  position: absolute;&#13;
  top: 0;&#13;
  left: 0;&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  pointer-events: none;&#13;
  opacity: 0.7;&#13;
  border-radius: 10px;&#13;
}&#13;
&#13;
.card-flipper {&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  position: relative;&#13;
  transition: transform 0.6s;&#13;
  transform-style: preserve-3d;&#13;
}&#13;
&#13;
.card-face {&#13;
  backface-visibility: hidden;&#13;
  position: absolute;&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  border-radius: 5%;&#13;
  top: 0;&#13;
  left: 0;&#13;
}&#13;
&#13;
.front-face {&#13;
  z-index: 2;&#13;
}&#13;
&#13;
.back-face {&#13;
  transform: rotateY(180deg);&#13;
}&#13;
&#13;
&#13;
.hover-buttons {&#13;
  position: absolute;&#13;
  top: 4.5rem;&#13;
  right: 0px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  z-index: 30;&#13;
}&#13;
&#13;
.hover-btn {&#13;
  background-color: rgba(249,250,251,.05);&#13;
  border: 2px solid hsla(0,0%,100%,.5);&#13;
  width: 5rem;&#13;
  height: 5rem;&#13;
  font-size: 3.5rem;&#13;
  font-weight: bolder;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
  transition: background-color .2s ease-in-out;&#13;
  padding: 0;&#13;
  line-height: 1;&#13;
  text-align: center;&#13;
}&#13;
&#13;
.hover-btn.flip {&#13;
  position: absolute;&#13;
  left: -20rem;&#13;
}&#13;
&#13;
&#13;
.hover-btn.card-modal {&#13;
  background-color: rgba(249,250,251,.05);&#13;
  border: 2px solid hsla(0,0%,100%,.5);&#13;
  font-size: 3.5rem;&#13;
  font-weight: bolder;&#13;
  width: 5rem;&#13;
  height: 5rem;&#13;
  z-index: 30;&#13;
}&#13;
&#13;
.hover-btn.minus {&#13;
  margin-bottom:1rem; &#13;
}&#13;
&#13;
.hover-btn:hover {&#13;
  background-color: rgba(249,250,251,.3);&#13;
}&#13;
&#13;
.price-info {&#13;
  display:flex;&#13;
  justify-content:center;&#13;
}&#13;
.image-container .back-face {&#13;
  display: none;&#13;
}&#13;
&#13;
.image-container.flipped .front-face {&#13;
  display: none;&#13;
}&#13;
&#13;
.image-container.flipped .back-face {&#13;
  display: block;&#13;
  transform: rotateY(0deg);&#13;
}&#13;
&#13;
.category-meta-row{&#13;
  display:flex;&#13;
  justify-content: space-between;&#13;
  font-weight:normal;&#13;
  font-size:1.2rem;&#13;
}&#13;
&#13;
.deck-controls {&#13;
 justify-content:center;&#13;
}&#13;
&#13;
.form-group label {&#13;
 font-weight:bold; &#13;
}&#13;
&#13;
.form-control {&#13;
  background-color:$brand-primary;&#13;
  color:white;&#13;
  border-color:$brand-secondary;&#13;
}</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>false</has_preview>
        <id>mtg_deck_view</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck View</name>
        <option_schema/>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
    // --- Quantity Update Handler ---
    if (input && input.card_sys_id && input.new_quantity !== undefined) {
        var updateGR = new GlideRecord("x_759224_magic_c_0_deck_card");
        if (updateGR.get(input.card_sys_id)) {
            updateGR.quantity = input.new_quantity;
            updateGR.update();
            data.success = true;
        } else {
            data.success = false;
            data.message = "Deck card not found.";
        }
        return;
    }

    // --- Regular Deck Loading Logic ---
    var deckId = (typeof input !== 'undefined' && input.deck_id) ? input.deck_id : $sp.getParameter("deck_id");
    data.categories = [];
    data.all_cards = [];
    data.deck_sys_id = deckId;

    if (!deckId) {
        data.error = "Missing deck_id";
        return;
    }

    var deckGR = new GlideRecord('x_759224_magic_c_0_mtg_deck');
    deckGR.addQuery('sys_id', deckId);
    deckGR.query();

    if (!deckGR.next()) {
        data.error = "Deck not found";
        return;
    }

    data.deck_name = deckGR.getValue('name');
    var authors = deckGR.getValue("author");
    data.is_author = authors.indexOf(gs.getUserID()) !== -1;

    var magicUtils = new x_759224_magic_c_0.magic_utils();

    var deckCardGR = new GlideRecord("x_759224_magic_c_0_deck_card");
    deckCardGR.addQuery("deck", deckId);
    deckCardGR.query();

    var categoryMap = {};
    var allCards = [];

    while (deckCardGR.next()) {
        var cardData = magicUtils.getCardData(deckCardGR.getValue('card'));
        cardData.flags.is_commander = deckCardGR.getValue("is_commander") == "1";
        cardData.flags.is_maybeboard = deckCardGR.getValue("is_maybeboard") == "1";
        cardData.flags.is_sideboard = deckCardGR.getValue("is_sideboard") == "1";
        cardData.quantity = deckCardGR.getValue('quantity');
        cardData.sys_id = deckCardGR.getUniqueValue();

        let category = "";
        if (cardData.flags.is_commander) {
            category = "Commander";
        } else {
            var notes = deckCardGR.getValue("notes") || "";
            var trimmedNote = notes.trim();
            if (trimmedNote) {
                var tags = trimmedNote.split(",");
                if (tags.length && tags[0].trim()) {
                    category = tags[0].trim();
                }
            }
            if (!category) {
                if (cardData.is_maybeboard) {
                    category = "Maybeboard";
                } else if (cardData.is_sideboard) {
                    category = "Sideboard";
                }
            }
            if (!category) {
                var typeLine = (cardData.face_one.type_line || "").toLowerCase();
                typeLine = typeLine.replace(/legendary|basic|snow|token|tribal/g, '').trim();
                var typePriority = [
                    { type: "creature", category: "Creature" },
                    { type: "planeswalker", category: "Planeswalker" },
                    { type: "instant", category: "Instant" },
                    { type: "sorcery", category: "Sorcery" },
                    { type: "enchantment", category: "Enchantment" },
                    { type: "artifact", category: "Artifact" },
                    { type: "battle", category: "Battle" },
                    { type: "land", category: "Land" }
                ];
                for (var i = 0; i < typePriority.length; i++) {
                    if (typeLine.indexOf(typePriority[i].type) !== -1) {
                        category = typePriority[i].category;
                        break;
                    }
                }
                if (!category) {
                    category = "Other";
                }
            }
        }
        if (!categoryMap[category]) {
            categoryMap[category] = [];
        }
        categoryMap[category].push(cardData);
        allCards.push(cardData);
    }

    // Sort cards within each category
    var orderedCategories = [];
    var commanderFirst = categoryMap["Commander"] ? ["Commander"] : [];
    // Custom ordering: Commander, (alphabetical others), Maybeboard, Sideboard
    var maybeboard = categoryMap["Maybeboard"] ? ["Maybeboard"] : [];
    var sideboard = categoryMap["Sideboard"] ? ["Sideboard"] : [];
   var rest = Object.keys(categoryMap)
    .filter(function(k){
        return k !== "Commander" && k !== "Maybeboard" && k !== "Sideboard";
    })
    .sort(function(a, b) {
        return categoryMap[a].length - categoryMap[b].length;
    });
    var allKeys = commanderFirst.concat(rest, maybeboard, sideboard);
    allKeys.forEach(function(key) {
        orderedCategories.push({
            name: key,
            cards: categoryMap[key]
        });
    });
    data.categories = orderedCategories;
    data.all_cards = allCards;
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 02:06:20</sys_created_on>
        <sys_id>4adc539ec3db22100efafbfdd401314d</sys_id>
        <sys_mod_count>220</sys_mod_count>
        <sys_name>MTG Deck View</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_4adc539ec3db22100efafbfdd401314d</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-12 21:15:44</sys_updated_on>
        <template><![CDATA[<div class="deck-controls" style="display: flex; gap: 2rem; align-items: flex-end; margin-bottom: 1rem;">
  <!-- Display As -->
  <div class="form-group">
    <label for="displayAs">Display As</label>
    <select id="displayAs" class="form-control" ng-model="layoutMode" ng-change="onLayoutChange()">
      <option value="columns">Columns</option>
      <option value="grid">Grid</option>
      <option value="text">Text</option>
    </select>
  </div>

  <!-- Group By -->
  <div class="form-group">
    <label for="groupBy">Group By</label>
    <select id="groupBy" class="form-control" ng-model="groupBy">
      <option value="category">Categories</option>
      <option value="type">Type</option>
      <option value="cmc">CMC</option>
    </select>
  </div>

  <!-- Sort By -->
  <div class="form-group">
    <label for="sortBy">Sort By</label>
    <select id="sortBy" class="form-control" ng-model="sortBy">
      <option value="alphabetical">Alphabetical</option>
      <option value="cmc">CMC</option>
      <option value="type">Type</option>
      <option value="price">Price</option>
    </select>
  </div>
</div>

<div class="deck-container" ng-if="layoutMode === 'columns'">
  <div class="deck-columns">
    <div class="deck-column" ng-repeat="cat in categories track by cat.name" ng-if="cat.name !== 'Maybeboard' && cat.name !== 'Sideboard'">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> <!-- placeholder for future actions/menu --> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container" ng-class="{'flipped': card.flags.is_flipped}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="deck-anchored-columns">
    <div class="deck-column" ng-repeat="cat in categories track by cat.name" ng-if="cat.name === 'Maybeboard'">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> <!-- placeholder for future actions/menu --> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container" ng-class="{'flipped': card.flags.is_flipped}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="deck-column" ng-repeat="cat in categories track by cat.name" ng-if="cat.name === 'Sideboard'">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> <!-- placeholder for future actions/menu --> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container" ng-class="{'flipped': card.flags.is_flipped}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="deck-container" ng-if="layoutMode === 'stacked'">
  <div class="deck-stacked">
    <div ng-repeat="cat in categories track by cat.name">
      <div class="deck-column-header category-header-flex">
        <div class="category-title-row">
          <h4 class="category-title">
            <!-- Use mana pip when grouped by CMC and header is numeric -->
            <img ng-if="groupBy === 'cmc' && !isNaN(parseInt(cat.name))"
                 ng-src="x_759224_magic_c_0.generic_{{ cat.name }}.svg"
                 alt="{{ cat.name }}"
                 style="height: 24px; vertical-align: middle;" />

            <!-- Fallback to name (for non-CMC headers like "Unknown") -->
            <span ng-if="groupBy !== 'cmc' || isNaN(parseInt(cat.name))">{{ cat.name }}</span>
          </h4>
          <span class="category-header-actions"> </span>
        </div>
        <div class="category-meta-row">
          <span class="category-qty">Qty: {{ getCategoryQuantity(cat) }}</span>
          <span class="category-price" ng-bind="'$' + (getCategoryPrice(cat) | number:2)"></span>
        </div>
      </div>
      <div class="card-stack stacked-mode">
        <div class="stacked-card"
             ng-repeat="card in cat.cards track by card.sys_id"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container" ng-class="{'flipped': card.flags.is_flipped}">
            <img class="image front-face" ng-src="{{card.face_one.image}}" alt="{{card.name}}" />
            <img class="image back-face" ng-if="card.face_two && card.face_two.image" ng-src="{{card.face_two.image}}" alt="{{card.name}} (Back)" />
            <div class="quantity-tag">{{card.quantity}}</div>
            <div class="game-changer-tag" ng-if="card.flags.is_gc">
              <img src='x_759224_magic_c_0.game_changer_diamond.png' class="game-changer-icon"/>
            </div>
            <img class="foil-overlay" src="x_759224_magic_c_0.foil.png" ng-if="card.flags.is_foil"/>
            <div class="hover-buttons">
              <button class="hover-btn flip" ng-if="card.flags.is_multifaced" ng-click="flipCard(card)">⟳</button>
              <button class="hover-btn plus" ng-if="is_author" ng-click="incrementCard(card, $event)">+</button>
              <button class="hover-btn minus" ng-if="is_author" ng-click="decrementCard(card, $event)">−</button>
              <button class="hover-btn card-modal" ng-click="openCardModal(card, $event)">></button>
            </div>
          </div>
          <div class="price-info">
            <div class="prices" ng-bind="'$' + (card.price | number:2)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
