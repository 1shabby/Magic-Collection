<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $window) {
    /* widget controller */
    var c = this;

    c.$onInit = function() {
        // Extract deck_id from URL if present and set it on input
        var params = new URLSearchParams($window.location.search);
        var deckIdParam = params.get('deck_id');
        if (deckIdParam) {
            c.data.deck_sys_id = deckIdParam;
        }
        $scope.customColumnSort = function(key) {
            return key === "Commander" ? '0000' : key;
        };

        $scope.sortedColumns = function() {
            const columns = [];

            angular.forEach($scope.data.columns, function(cards, key) {
                columns.push({
                    key: key,
                    cards: cards
                });
            });

            return columns.sort(function(a, b) {
                if (a.key === 'Commander') return -1;
                if (b.key === 'Commander') return 1;
                return a.key.localeCompare(b.key);
            });
        };



        $scope.getCardTags = function(card) {
            var tags = [];
            if (card.is_commander) tags.push("Commander");
            if (card.is_maybeboard) tags.push("Maybeboard");
            if (card.is_sideboard) tags.push("Sideboard");
            return tags.join(", ");
        };
    };
};]]></client_script>
        <controller_as>c</controller_as>
        <css>.deck-container {&#13;
  display: flex;&#13;
  flex-wrap: wrap;&#13;
  align-items: flex-start;&#13;
  padding: 1rem;&#13;
  gap: 2rem;&#13;
  width: 100%;&#13;
  overflow-x: auto;&#13;
}&#13;
&#13;
.deck-columns {&#13;
  display: flex;&#13;
  flex-wrap: wrap;&#13;
  gap: 2rem;&#13;
  flex: 1;&#13;
}&#13;
&#13;
.deck-anchored-columns {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  gap: 2rem;&#13;
  flex-shrink: 0;&#13;
}&#13;
&#13;
/* Column Styling */&#13;
.deck-column {&#13;
  flex: 0 0 auto;&#13;
  min-width: 200px;&#13;
  max-width: 250px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  align-items: center;&#13;
  overflow: visible;&#13;
}&#13;
&#13;
.deck-column-header {&#13;
  font-weight: bold;&#13;
  font-size: 1.1rem;&#13;
  color: white;&#13;
  margin-bottom: 1rem;&#13;
  text-align: center;&#13;
}&#13;
&#13;
/* Card Stack */&#13;
.card-stack {&#13;
  position: relative;&#13;
  width: 100%;&#13;
  overflow: visible;&#13;
}&#13;
&#13;
/* Stack Overlap */&#13;
.stacked-card {&#13;
  position: relative;&#13;
  margin-top: -25rem;&#13;
  transition: transform 0.2s ease;&#13;
  z-index: 1;&#13;
}&#13;
&#13;
/* Top card and single-card columns shouldn't overlap */&#13;
.stacked-card:first-child {&#13;
  margin-top: 0;&#13;
}&#13;
&#13;
/* Prevent shifting on hover if it's the only card */&#13;
.card-stack:only-child .stacked-card:hover {&#13;
  transform: none !important;&#13;
}&#13;
&#13;
/* Only shift hovered card forward */&#13;
.stacked-card:hover {&#13;
  z-index: 999 !important;&#13;
}&#13;
&#13;
/* Move only the cards *after* the hovered one downward */&#13;
.stacked-card:hover ~ .stacked-card {&#13;
  transform: translateY(25rem);&#13;
}&#13;
&#13;
/* Image Container */&#13;
.image-container {&#13;
  width: 100%;&#13;
  max-width: 200px;&#13;
  border-radius: 5%;&#13;
  overflow: hidden;&#13;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);&#13;
}&#13;
&#13;
.image {&#13;
  width: 100%;&#13;
  border-radius: 5%;&#13;
  display: block;&#13;
}&#13;
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>false</has_preview>
        <id>mtg_deck_view</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck View</name>
        <option_schema/>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
  var deckId = (typeof input !== 'undefined' && input.deck_id) ? input.deck_id : $sp.getParameter("deck_id");
  data.columns = {};
  data.deck_sys_id = deckId;

  if (!deckId) {
    data.error = "Missing deck_id";
    return;
  }

  var deckCardGR = new GlideRecord("x_759224_magic_c_0_deck_card");
  deckCardGR.addQuery("deck", deckId);
  deckCardGR.query();

  while (deckCardGR.next()) {
    var cardGR = deckCardGR.card.getRefRecord();
    if (!cardGR.isValidRecord()) continue;

    var frontImage = getImageURL(cardGR.getValue("front_image"));

    var cardData = {
      name: cardGR.getValue("name"),
      quantity: deckCardGR.getValue("quantity"),
      price: cardGR.getValue("price"),
      front_image_url: frontImage,
      is_commander: deckCardGR.getValue("is_commander") == "1",
      is_maybeboard: deckCardGR.getValue("is_maybeboard") == "1",
      is_sideboard: deckCardGR.getValue("is_sideboard") == "1"
    };

    let category = "";

    // Commander category renamed here
    if (cardData.is_commander) {
      category = "Commander";
    } else {
      var notes = deckCardGR.getValue("notes") || "";
      var trimmedNote = notes.trim();

      if (trimmedNote) {
        var tags = trimmedNote.split(",");
        if (tags.length && tags[0].trim()) {
          category = tags[0].trim();
        }
      }

      if (!category) {
        if (cardData.is_maybeboard) {
          category = "Maybeboard";
        } else if (cardData.is_sideboard) {
          category = "Sideboard";
        }
      }

      if (!category) {
        var typeLine = (cardGR.getValue("type_line") || "").toLowerCase();
        typeLine = typeLine.replace(/legendary|basic|snow|token|tribal/g, '').trim();

        var typePriority = [
          { type: "creature", category: "Creature" },
          { type: "planeswalker", category: "Planeswalker" },
          { type: "instant", category: "Instant" },
          { type: "sorcery", category: "Sorcery" },
          { type: "enchantment", category: "Enchantment" },
          { type: "artifact", category: "Artifact" },
          { type: "battle", category: "Battle" },
          { type: "land", category: "Land" }
        ];

        for (var i = 0; i < typePriority.length; i++) {
          if (typeLine.indexOf(typePriority[i].type) !== -1) {
            category = typePriority[i].category;
            break;
          }
        }

        if (!category) {
          category = "Other";
        }
      }
    }

    if (!data.columns[category]) {
      data.columns[category] = [];
    }

    data.columns[category].push(cardData);
  }

  for (var column in data.columns) {
    data.columns[column].sort(function(a, b) {
      return a.name.localeCompare(b.name);
    });
  }

  // Rename here too: ensure Commander first
  if (data.columns["Commander"]) {
    const reordered = { "Commander": data.columns["Commander"] };

    Object.keys(data.columns).sort().forEach(function(key) {
      if (key !== "Commander") {
        reordered[key] = data.columns[key];
      }
    });

    data.columns = reordered;
  }

  function getImageURL(html) {
    if (!html) return "";
    var match = html.match(/<img[^>]+src="([^"]+)"/);
    return match ? match[1] : "";
  }
})();
]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-08-14 02:06:20</sys_created_on>
        <sys_id>4adc539ec3db22100efafbfdd401314d</sys_id>
        <sys_mod_count>29</sys_mod_count>
        <sys_name>MTG Deck View</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_4adc539ec3db22100efafbfdd401314d</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-08-15 18:04:38</sys_updated_on>
        <template><![CDATA[<div class="deck-container">
  <!-- Wrapping Deck Columns -->
  <div class="deck-columns">
    <div class="deck-column"
         ng-repeat="col in sortedColumns() track by col.key"
         ng-if="col.key !== 'Maybeboard' && col.key !== 'Sideboard'">
      <div class="deck-column-header">{{ col.key }}</div>

      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in col.cards"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container">
            <img class="image" ng-src="{{card.front_image_url}}" alt="{{card.name}}" />
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Anchored Columns: Maybeboard + Sideboard -->
  <div class="deck-anchored-columns">
    <div class="deck-column"
         ng-repeat="col in sortedColumns() track by col.key"
         ng-if="col.key === 'Maybeboard' || col.key === 'Sideboard'">
      <div class="deck-column-header">{{ col.key }}</div>

      <div class="card-stack">
        <div class="stacked-card"
             ng-repeat="card in col.cards"
             ng-style="{'z-index': ($index + 1) * 10}">
          <div class="image-container">
            <img class="image" ng-src="{{card.front_image_url}}" alt="{{card.name}}" />
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
]]></template>
    </sp_widget>
</record_update>
