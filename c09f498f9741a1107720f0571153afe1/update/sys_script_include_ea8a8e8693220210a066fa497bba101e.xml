<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_759224_magic_c_0.playtest_utils</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description>Contains methods for use in the playtester widget.</description>
        <mobile_callable>false</mobile_callable>
        <name>playtest_utils</name>
        <sandbox_callable>true</sandbox_callable>
        <script><![CDATA[var playtest_utils = Class.create();
playtest_utils.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {

    initialize: function(debug, noDebugMethods) {
        this.debug = false; // Flag to allow debug or not on this script include
        this.noDebugMethods = []; // Array of methods to not log from

        if (debug) {
            gs.info(debug);
            this.debug = debug;
        }

        if (noDebugMethods) {
            this.noDebugMethods = noDebugMethods.split(',');
        }
        // Script Includes
        this.constants = new x_759224_magic_c_0.mtg_constants();
        this.magicUtils = new x_759224_magic_c_0.magic_utils();

        this.format;

        this.hp;
        this.turn = 0;
        this.actions = [];
        this.zones = {
            commandZone: [],
            hand: [],
            library: [],
            battlefield: [],
            graveyard: [],
            exile: [],
            sideboard: [],
            maybeboard: []
        };
        this.flags = {
            commander_required: false,
            uses_sideboard: false
        };
    },
    /*
     * Description: Loads in a deck via the provided deckID
     * Parameters: [string] deckID: Sys_id of a deck record
     * Returns: [object] retObj: Object containing execution details
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     * 				[object] zones: Stores the zones object that is populated in a successful execution
     */

    loadDeck: function(deckID) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Load Deck'
            };
            if (typeof(deckID) === 'string' && deckID != '') { // Validate deckID is a string and not empty
                var deckGR = new GlideRecord(this.constants.tables.DECK);
                if (deckGR.get(deckID)) {
                    this.addAction(retObj);
                    var formatSysID = deckGR.getValue('format');

                    var format = this._getFormatInfo(formatSysID);
                    if (!format.success) {
                        retObj.success = false;
                        retObj.message = format.message;
                        retObj.this.zones;
                    }

                    var populated = this._populateZones(deckID); // Populate zones object with deck cards
                    if (!populated.success) { // If populate zones failed
                        retObj.success = false;
                        retObj.message = populated.message;
                        retObj.zones = this.zones;
                    }
                }
                var shuffled = this.shuffle(this.zones.library); // Shuffle the library
                if (!shuffled.success) { // Shuffle method failed
                    retObj.success = false;
                    retObj.message = shuffled.message;
                    retObj.zones = this.zones;
                }
                var drawn = this.draw(this.zones.library, this.zones.hand, 7); // Draw opening hand
                if (!drawn.success) { // Draw method failed
                    retObj.success = false;
                    retObj.message = drawn.message;
                    retObj.zones = this.zones;
                }

            } else { // DeckID is not valid
                retObj.success = false;
                retObj.message = "Deck ID '" + deckID + "' is not valid.";
                retObj.zones = this.zones;
            }

            retObj.message = 'Deck properly loaded.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
        }

        return retObj;
    },

    /*
     * Description: Gets the format information for the format associated to the deck
     * Parameters: [string] formatSysID: sys_id of the format associated to the deck record
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     */

    _getFormatInfo: function(formatSysID) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Get Format Info'
            };

            var formatGR = new GlideRecord(this.constants.tables.DECK_FORMATS);
            if (formatGR.get(formatSysID)) {
                this.hp = parseInt(formatGR.getValue('starting_hp'), 10); // Set starting HP based on format
                this.format = formatGR.getValue('name'); // Sets the name of the format
                this.flags.commander_required = formatGR.getValue('commander_required') == '1'; // Check if commander is required for this format
                this.flags.uses_sideboard = formatGR.getValue('uses_sideboard') == '1'; // Check if sideboard is used for this format
            }

            retObj.message = 'Format information properly set.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
        }

        this.addAction(retObj);
        return retObj;
    },

    /*
     * Description: Helper method to populate the arrays in the zones object
     * Parameters: [string] deckID: sys_id of the deck record
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     */

    _populateZones: function(deckID) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Populate Zones'
            };
            var deckCardGR = new GlideRecord(this.constants.tables.DECK_CARDS);
            deckCardGR.addQuery('deck', deckID);
            deckCardGR.query();
            while (deckCardGR.next()) {
                if (deckCardGR.is_commander.toString() === 'true') { // Card is commander
                    var commander = this.magicUtils.getCardData(deckCardGR.getValue('card'));
                    commander.flags.is_commander = true; // Set Commander Flag
                    commander.flags.is_tapped = false;
                    commander.notes = deckCardGR.getValue('notes'); // Set any notes from deck card
                    for (i = 0; i < deckCardGR.getValue('quantity'); i++) { // Push to commandZone
                        this.zones.commandZone.push(commander);
                    }
                } else if (deckCardGR.is_sideboard.toString() === 'true') { // Card is sideboard
                    var sideboard = this.magicUtils.getCardData(deckCardGR.getValue('card'));
                    sideboard.flags.is_sideboard = true; // Set Sideboard flag
                    sideboard.flags.is_tapped = false;
                    sideboard.notes = deckCardGR.getValue('notes'); // Set any notes from the deck card
                    for (i = 0; i < deckCardGR.getValue('quantity'); i++) { // Push to sideboard
                        this.zones.sideboard.push(sideboard);
                    }
                } else if (deckCardGR.is_maybeboard.toString() === 'true') { // Card is maybeboard
                    var maybeboard = this.magicUtils.getCardData(deckCardGR.getValue('card'));
                    maybeboard.flags.is_maybeboard = true; // Set maybeboard flag
                    maybeboard.flags.is_tapped = false;
                    maybeboard.notes = deckCardGR.getValue('notes'); // Set any notes from the deck card
                    for (i = 0; i < deckCardGR.getValue('quantity'); i++) { // Push to maybeboard
                        this.zones.maybeboard.push(maybeboard);
                    }
                } else { // Card is in the main deck
                    var library = this.magicUtils.getCardData(deckCardGR.getValue('card'));
                    library.notes = deckCardGR.getValue('notes'); // Set any notes from the deck card
                    library.flags.is_tapped = false;
                    for (i = 0; i < deckCardGR.getValue('quantity'); i++) { // Push = to quantity
                        this.zones.library.push(library);
                    }
                }
            }

            retObj.message = 'Zones properly populated.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
        }

        this.addAction(retObj);
        return retObj;

    },

    /*
     * Description: Shuffles an array
     * Parameters: [array] array that is going to be shuffled
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     * 				[array] arr: Stores the shuffled array
     */

    shuffle: function(array) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Shuffle',
                array: array
            };

            var currentIndex = array.length,
                randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                var temp = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temp;
            }

            retObj.arr = array;
            retObj.message = 'Array properly shuffled.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
            retObj.array = array;
        }

        this.addAction(retObj);
        return retObj;
    },

    /*
     * Description: Takes in two arrays then if the first array has at least 1 element it takes it and puts it on top of the second array.
     * Parameters: [array] Array1: Array to draw from
     *			   [array] Array2: Array to draw to
     *			   [integer] Count: Number of cards to draw
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     * 				[object] arrays: Stores array1 and array2 post draw
     */

    draw: function(array1, array2, count) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Draw',
                arrays: {
                    array1,
                    array2
                }
            };

            if (array1.length >= parseInt(count)) {
                for (i = 0; i < count; i++) {
                    var topCard = array1.shift();
                    array2.push(topCard);
                }
            }

            retObj.message = count + ' cards were drawn successfully.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
            retObj.arrays.array1 = array1;
            retObj.arrays.array2 = array2;
        }

        this.addAction(retObj);
        return retObj;
    },

    /*
     * Description: Copies the top n cards from an array to a temporary array for the user to view
     * Parameters: [array] array: Array of cards to peek into
     * 			   [integer] count: Number of cards deep to peek
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     * 				[array] temp: Temporary array that stores the peek items
     */

    peek: function(array, count) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Peek',
                temp: []
            };

            if (count <= 0) {
                retObj.success = false;
                retObj.message = 'Count must be greater than 0';
            } else {
                if (array.length >= parseInt(count)) {
                    retObj.temp = array.slice(0, count);
                } else {
                    retObj.success = false;
                    retObj.message = 'Array length of ' + array.length + ' is shorter than ' + count;
                }
            }

            retObj.message = 'Peek performed successfully.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
            retObj.temp = [];
        }
        this.addAction(retObj);
        return retObj;

    },

    /*
     * Description: Iterates through an array and untaps all cards
     * Parameters: [array] array: Array of cards to loop through
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     * 				[array] array: Stores the shuffled array
     */

    untapAll: function(array) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Untap All',
                array: array
            };

            // Loop through each item in the array and set the is_tapped flag to false
            for (i = 0; i < array.length; i++) {
                array[i].flags.is_tapped = false;
            }

            this.message = 'All cards untapped.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
            retObj.array = array;
        }
        this.addAction(retObj);
        return retObj;
    },

    /*
     * Description: Starts a new turn by untapping all cards, incrementing the turn counter, and drawing a card
     * Parameters: None
     * Returns: [object]: contains execution information
     * 				[boolean] success: Tracks whether the method exuected successfully
     * 				[string] message: Stores any messages related to execution
     */

    newTurn: function() {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'New Turn'
            };

            var untap = this.untapAll(this.zones.battlefield); // Untap all cards
            if (!untap.success) {
                retObj.success = false;
                retObj.message = untap.message;
            }
            this.turn++; // Increment turn counter
            var draw = this.draw(this.zones.library, this.zones.hand, 1); // Draw a card
            if (!draw.success) {
                retObj.success = false;
                retObj.message = draw.message;
            }

            retObj.message - 'New turn started.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.messsage;
        }
        this.addAction(retObj);
        return retObj;
    },

    /*
     * Description: Sets a counter on a card to a specific amount
     * Parameters: [object] card: Card object to set counter on
     *             [string] counterType: Type of counter to set
     *             [integer] amount: Amount to set the counter to
     * Returns: [object] : Contains execution information
     * 				[boolean] Status: status
     * 				[string] Message: any messages from the execution
     */

    setCounters: function(card, counterType, amount) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Set Counters',
                card: card
            };

            if (typeof counterType === 'string' && typeof amount === 'number' && card.hasOwnProperty('counters')) {
                card.counters[counterType] = amount; // Set counters
                retObj.message = amount.toString() + ' ' + counterType.toString() + ' counters added to card.';
            } else if (typeof counterType != 'string') {
                retObj.success = false;
                retObj.message = 'Counter type of ' + counterType.toString() + ' is not a string.';
            } else if (typeof amount != 'number') {
                retObj.success = false;
                retObj.message = 'Amount provided ' + amount.toString() + ' is not a number.';
            } else if (!card.hasOwnProperty('counters')) {
                retObj.success = false;
                retObj.message = 'Provided card object is missing counters property.';
            }

            retObj.message = amount + ' ' + counterType + ' added to ' + card.name + '.';

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
            retObj.card = card;
        }
        this.addAction(retObj);
        return retObj;
    },

    /*
     * Description: Adds the provided amount to the player's hp
     * Parameters: [integer] amount: The amount of hp to add to the user's hp
     * Returns: [object] retObj: Contains execution information
     * 				[boolean] success: Contains execution status information
     * 				[string] message: Contains any execution messages
     * 				[integer] hp: Updated HP
     */

    setLife: function(amount) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Set Life'
            };

            if (typeof(amount) === 'number') {
                this.hp += amount;
                retObj.message = amount + " life added to hp setting hp to " + this.hp + '.';
            } else {
                retObj.success = false;
                retObj.message = amount + ' is not a number.';
            }

        } catch (ex) {
            retObj.success = false;
            retObj.message = ex.message;
        }

        this.addAction(retObj);
        return retObj;
    },

    /**
     * Description: Adds an action to the action log 
     * Parameters: [object] action: Action to add to action log
     * Returns: [object] retObj: Contains execution information
     * 				[boolean] success: Contains execution status information
     * 				[string] message: Contains any execution messages
     */

    addAction: function(action) {
        try {
            var retObj = {
                success: true,
                message: '',
                method: 'Add Action'
            };
        
        if (action.hasOwnProperty('success')) {
            this.actions.push(action);
            if (this.debug) {
                gs.info('[Playtester Utils] : ' + action.success + ' | ' +
                    action.message + ' | ' +
                    action.method);
            }
        } else {
            retObj.success = false;
            retObj.messate = 'Action missing success key.';
        }
    } catch (ex) {
        retObj.success = false;
        retObj.message = ex.message;
    }
    return retObj;
},

type: 'playtest_utils'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-06-04 02:18:12</sys_created_on>
        <sys_id>ea8a8e8693220210a066fa497bba101e</sys_id>
        <sys_mod_count>86</sys_mod_count>
        <sys_name>playtest_utils</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sys_script_include_ea8a8e8693220210a066fa497bba101e</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-16 04:24:23</sys_updated_on>
    </sys_script_include>
</record_update>
