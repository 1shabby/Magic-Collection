<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_759224_magic_c_0.magic_utils</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description>Generic Utils for the Magic Collection application.</description>
        <mobile_callable>false</mobile_callable>
        <name>magic_utils</name>
        <sandbox_callable>true</sandbox_callable>
        <script><![CDATA[var magic_utils = Class.create();
magic_utils.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {
    initialize: function(debug, noDebugMethods) {
        this.debug = false; // Flag to allow debug or not on this script include
        this.noDebugMethods = []; // Array of methods to not log from

        if (debug) {
            this.debug = debug;
        }

        if (noDebugMethods) {
            this.noDebugMethods = noDebugMethods.split(',');
        }

        // Global Variables
        this.CARDS = 'x_759224_magic_c_0_mtg_cards';
        this.SETS = 'x_759224_magic_c_0_mtg_sets';
        this.TOKEN_ASSOCIATION = 'x_759224_magic_c_0_token_association';
        this.OWNED_CARDS = 'x_759224_magic_c_0_owned_card';

    },

    /**
     * Description: Takes in a method name and message and logs the message in gs.info if debug and method isn't in noDebugMethods
     * Parameters: [string] - methodName: name of method calling log.
                   [string] - msg: message being called in log.
     * Returns: None.
     */

    log: function(methodName, msg) {
        if (this.debug && this.noDebugMethods.indexOf(methodName) === -1) {
            gs.info('[Magic Utils - ' + methodName + '] ' + msg);
        }
    },

    /**
     * Description: Takes in set_id and returns the set record on the system
     * Parameters: [string] - set_id: the string id used to identify a set
     * Returns: [object]: Set record object.
     */

    getSetRecord: function(set_id) {
        var setGR = new GlideRecord(this.SETS);
        return setGR.get('id', set_id);
    },

    /* Description: Creates a owned card record for the provided card and user with the qty or default to 1
     * Parameters: [string] - card: sys id of the card to be associated to the user
     			   [string] - user: sys id of the user the card will be associated to
				   [integer] - qty: Quantity of the cards the user has, optional param defaults to 1
     * Returns: [object]: Contains a success flag and the record if success, or msg if failure
     */

    createOwnedRecord: function(card, user, qty) {
        try {
            var newOwned = new GlideRecord(this.OWNED_CARDS);
            newOwned.initialize();
            newOwned.setValue('card', card);
            newOwned.setValue('owner', user);
            newOwned.setvalue('quantity', qty || 1);
            newOwned.insert();

            return {
                success: true,
                record: newOwned
            };
        } catch (ex) {
            return {
                success: false,
                msg: ex.message()
            };
        }
    },

    /* Description: Creates a token record for the provided name and scryfall ID 
     * Parameters: [string] - name: Name of the token to be created
     			   [string] - id: Scryfall ID of the token. Used for generating association later
     * Returns: [object]: Contains a success flag and the record if success, or msg if failure
     */

    createToken: function(name, id) {
        try {
            var newToken = new GlideRecord(this.CARDS);
            newToken.initialize();
            newToken.setValue('name', name);
            newToken.setValue('scryfall_id', id);
            newToken.insert();

            return {
                success: true,
                record: newToken
            };
        } catch (ex) {
            return {
                success: false,
                msg: ex.message()
            };
        }
    },

    /** 
    * Description: Creates a token association record for the provided card and token records
	* Parameters: [object] - card: Card GlideRecord object
				  [object] - token: Token Card GlideRecord object
	* Returns: [object]: Contains a success flag and the record if success, or msg if failure
	*/

    createTokenAssociation: function(card, token) {
        try {
            var newTokenAssociation = new GlideRecord(this.TOKEN_ASSOCIATION);
            newTokenAssociation.initialize();
            newTokenAssociation.setValue('token', token.getUniqueValue());
            newTokenAssociation.setValue('card', card.sys_id);
            newTokenAssociation.insert();

            return {
                success: true,
                record: newTokenAssociation
            };
        } catch (ex) {
            return {
                success: false,
                msg: ex.message()
            };
        }
    },

    /**
     * Description: Takes in either a object or sys_id of the card and token and returns the number of associations for them
     * Parameters: [object / string] - card: Either a GlideRecord object or sys_id of the card record
     * 			   [object / string] - token: Either a GlideRecord object or sys_id of the token record
     * Returns: [integer]: The number of associations for the provided card and token
     */

    getTokenAssociationCount: function(card, token) {
        var associationGR = new GlideRecord(this.TOKEN_ASSOCIATION);

        var cardSysId = (card && typeof card.getUniqueValue === 'function') ? card.getUniqueValue() : card;
        var tokenSysId = (token && typeof token.getUniqueValue === 'function') ? token.getUniqueValue() : token;

        if (!cardSysId || !tokenSysId)
            return 0;

        associationGR.addQuery('card', cardSysId);
        associationGR.addQuery('token', tokenSysId);
        associationGR.query();

        return associationGR.getRowCount();
    },

    /**
     * Description: Takes in an image string (generally the html one from a card) and grabs the source link of the image. If there isn't one, sets it to be the default mtg backing.
     * Parameters: [string] - img: The value from the image field on a card.
     * Returns: [string]: source url for the image, or the default back image.
     */

    getImgSrc: function(img) {
        var regex = /<img[^>]*\s+src=["']([^"']+)["']/i;
        //gs.info(img);
        if (img)
            var match = img.match(regex);
        var retval = '';
        if (match && match[1]) {
            retval = match[1];
        } else {
            retval = 'x_759224_magic_c_0.card-back.png';
        }
        return retval;
    },

    /**
     * Description: Takes in HTML from an HTML field and returns the content inside without HTML. 
     * Parameters: [string] - html: The HTML from a HTML field.
     * Returns: [string]: Contents inside of the HTML.
     */

    stripHTML: function(html) {
        return html.replace(/<[^>]*>/g, '');
    },

    /**
     * Description: Takes in a comma separated string of colors and converts them to the full color name. 
     * Parameters: [string]: colors - The colors field (ex: W,U = White, Blue).
     * Returns: [string]: Comma separated string of colors in the form of White,Blue rather than W,U.
     */

    convertColors: function(colors) {
        if (!colors) return "";

        var map = {
            B: 'Black',
            W: 'White',
            U: 'Blue',
            R: 'Red',
            G: 'Green',
            C: 'Colorless'
        };

        var order = ['White', 'Blue', 'Black', 'Red', 'Green', 'Colorless'];

        return colors
            .toUpperCase()
            .split('')
            .map(c => map[c] || '')
            .filter(c => c && c.trim() !== '')
            .sort((a, b) => order.indexOf(a) - order.indexOf(b))
            .join(', ');
    },
    /**
     * Description: Takes in an id string for a card. 
     * Parameters: [string] - id: The sys id of the card record.
     * Returns: [Array] - relArr: An array of JSON objects containg the related card name and image.
     */

    getRelatedCards: function(id) {
        var relGR = new GlideRecord(this.TOKEN_ASSOCIATION);
        relGR.addQuery('card', id);
        relGR.query();
        var relArr = [];

        while (relGR.next()) {
            var token = relGR.token.getRefRecord();
            relObj = {
                name: token.getValue('name'),
                image: this.getImgSrc(token.getValue('front_image')),
                is_foil: token.getValue('foiling') != 'none'
            };
            relArr.push(relObj);
        }
        return relArr;
    },

    /**
     * Description: Takes in an name string for a card. 
     * Parameters: [string] - name: The name of the card record.
     * Returns: [object] - cardData: JSON object containing all the data from the card record.
     */

    getOtherPrintings: function(name) {
        var cardGR = new GlideRecord(this.CARDS);
        cardGR.addQuery('is_token', false);
        cardGR.addQuery('name', name);
        cardGR.query();
        printingArr = [];

        while (cardGR.next()) {
            printingObj = {
                image: this.getImgSrc(cardGR.getValue('front_image')),
                price: cardGR.getValue('price'),
                sets: cardGR.getDisplayValue('sets'),
                is_foil: cardGR.getValue('foiling') != 'none'
            };
            printingArr.push(printingObj);
        }
        return printingArr;
    },

    /**
     * Description: Takes in an id string for a card, and builds out an object containing the data
     * Parameters: [string] - id: The sys id of the card record.
     * Returns: [object] - cardData: JSON object containing all the data from the card record.
     */

    getCardData: function(id) {
        var cardGR = new GlideRecord(this.CARDS);
        cardGR.get(id); // Get the card record.
        var cardData = {
            legality: { // Legalities for the card.
                alchemy: this.stripHTML(cardGR.getValue('alchemy_legality')) == 'Legal',
                brawl: this.stripHTML(cardGR.getValue('brawl_legality')) == 'Legal',
                commander: this.stripHTML(cardGR.getValue('commander_legality')) == 'Legal',
                duel: this.stripHTML(cardGR.getValue('duel_legality')) == 'Legal',
                future: this.stripHTML(cardGR.getValue('future_legality')) == 'Legal',
                gladiator: this.stripHTML(cardGR.getValue('gladiator_legality')) == 'Legal',
                historic: this.stripHTML(cardGR.getValue('historic_legality')) == 'Legal',
                legacy: this.stripHTML(cardGR.getValue('legacy_legality')) == 'Legal',
                modern: this.stripHTML(cardGR.getValue('modern_legality')) == 'Legal',
                oathbreaker: this.stripHTML(cardGR.getValue('oathbreaker_legality')) == 'Legal',
                oldschool: this.stripHTML(cardGR.getValue('oldschool_legality')) == 'Legal',
                pauper_commander: this.stripHTML(cardGR.getValue('paupercommander_legality')) == 'Legal',
                pauper: this.stripHTML(cardGR.getValue('pauper_legality')) == 'Legal',
                penny: this.stripHTML(cardGR.getValue('penny_legality')) == 'Legal',
                pioneer: this.stripHTML(cardGR.getValue('pioneer_legality')) == 'Legal',
                predh: this.stripHTML(cardGR.getValue('predh_legality')) == 'Legal',
                premodern: this.stripHTML(cardGR.getValue('premodern_legality')) == 'Legal',
                standard_brawl: this.stripHTML(cardGR.getValue('standardbrawl_legality')) == 'Legal',
                standard: this.stripHTML(cardGR.getValue('standard_legality')) == 'Legal',
                timeless: this.stripHTML(cardGR.getValue('timeless_legality')) == 'Legal',
                vintage: this.stripHTML(cardGR.getValue('vintage_legality')) == 'Legal'
            },
            flags: { // Card flags.
                is_foil: cardGR.getValue('foiling') != 'none',
                is_reserved: cardGR.getValue('reserved_list') == '1',
                is_gc: cardGR.getValue('game_changer') == '1',
                is_token: cardGR.getValue('is_token') == '1',
                is_multifaced: cardGR.getValue('is_multi_faced') == '1',
                // Deck card flags
                is_commander: false,
                is_maybeboard: false,
                is_sideboard: false,
                is_flipped: false
            },
            face_one: { // Face one data.
                artist: cardGR.getValue('face_one_artist'),
                colors: this.convertColors(cardGR.getValue('face_one_colors')),
                flavor_name: cardGR.getValue('face_one_flavor_name'),
                flavor_text: cardGR.getValue('face_one_flavor_text'),
                image: this.getImgSrc(cardGR.getValue('front_image')),
                loyalty: cardGR.getValue('face_one_loyalty'),
                mana_cost: cardGR.getValue('face_one_mana_cost'),
                name: cardGR.getValue('face_one_name'),
                oracle_text: cardGR.getValue('face_one_oracle_text'),
                power: cardGR.getValue('face_one_power'),
                toughness: cardGR.getValue('face_one_toughness'),
                type_line: cardGR.getValue('type_line')
            },
            face_two: { // Face two data
                artist: cardGR.getValue('face_two_artist'),
                colors: this.convertColors(cardGR.getValue('face_two_colors')),
                flavor_name: cardGR.getValue('face_two_flavor_name'),
                flavor_text: cardGR.getValue('face_two_flavor_text'),
                image: this.getImgSrc(cardGR.getValue('back_image')),
                loyalty: cardGR.getValue('face_two_loyalty'),
                mana_cost: cardGR.getValue('face_two_mana_cost'),
                name: cardGR.getValue('face_two_name'),
                oracle_text: cardGR.getValue('face_two_oracle_text'),
                power: cardGR.getValue('face_two_power'),
                toughness: cardGR.getValue('face_two_toughness'),
                type_line: cardGR.getValue('face_two_type_line')
            },
            links: { // Links associated to the card
                edhrec: cardGR.getValue('edhrec'),
                gatherer: cardGR.getValue('gatherer'),
                cardhoarder: cardGR.getValue('cardhoarder_purchase'),
                cardmarket: cardGR.getValue('cardmarket_purchase'),
                tcgplayer: cardGR.getValue('tcgplayer_purchase')
            },
            counters: { // Counters availble to put on cards.
                generic: 0,
                plusOne: 0,
                minusOne: 0,
                loyalty: cardGR.getValue('face_one_loyalty') || cardGR.getValue('face_two_loyalty') || 0,
                lore: 0,
                time: 0,
                shield: 0,
                charge: 0,
                lifelink: 0,
                haste: 0,
                indestructible: 0,
                flying: 0,
                deathtouch: 0,
                menace: 0,
                trample: 0,
                firstStrike: 0,
                doubleStrike: 0,
                reach: 0,
                vigilance: 0
            },
            related_cards: this.getRelatedCards(id),
            printings: this.getOtherPrintings(cardGR.getValue('name')),
            price: cardGR.getValue('price'),
            quantity: 0,
            name: cardGR.getValue('name'),
            cmc: cardGR.getValue('cmc'),
            colors: this.convertColors(cardGR.getValue('colors')),
            sets: cardGR.getDisplayValue('sets'),
            cn: cardGR.getValue('collector_number')
        };
        return cardData;
    },

    type: 'magic_utils'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-05-31 01:08:27</sys_created_on>
        <sys_id>7b63953c936a0210a066fa497bba10db</sys_id>
        <sys_mod_count>121</sys_mod_count>
        <sys_name>magic_utils</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sys_script_include_7b63953c936a0210a066fa497bba10db</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-10 03:26:26</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>7b63953c936a0210a066fa497bba10db</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-11-19 00:52:03</sys_created_on>
        <sys_id>7c028bc8c3021210b7cebd73e401319a</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-11-19 00:52:03</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
