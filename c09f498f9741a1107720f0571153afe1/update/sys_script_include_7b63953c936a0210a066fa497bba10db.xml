<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_759224_magic_c_0.magic_utils</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description>Generic Utils for the Magic Collection application.</description>
        <mobile_callable>false</mobile_callable>
        <name>magic_utils</name>
        <sandbox_callable>true</sandbox_callable>
        <script><![CDATA[var magic_utils = Class.create();
magic_utils.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {
    initialize: function(debug, noDebugMethods) {
        this.debug = false; // Flag to allow debug or not on this script include
        this.noDebugMethods = []; // Array of methods to not log from

        if (debug) {
            this.debug = debug;
        }

        if (noDebugMethods) {
            this.noDebugMethods = noDebugMethods.split(',');
        }
        this.constants = new x_759224_magic_c_0.mtg_constants();
        // Global Table Variables
        this.CARDS = this.constants.tables.CARDS;
        this.HISTORICAL_PRICES = this.constants.tables.HISTORICAL_CARD_PRICES;
        this.SETS = this.constants.tables.SETS;
        this.KEYWORDS = this.constants.tables.KEYWORDS;
        this.TOKEN_ASSOCIATION = this.constants.tables.TOKEN_ASSOCIATION;
        this.OWNED_CARDS = this.constants.tables.OWNED_CARDS;
        // Fields to always populate on a card.
        this.GENERAL_FIELDS = [
            'name', 'rarity', 'cmc', 'game_changer', 'keywords',
            'reserved_list', 'is_multi_faced'
        ]
        // Time in hours to wait before creating another historic price record for a card.
        this.HISTORIC_PRICE_WAIT = 24;

    },

    /**
     * Description: Takes in a method name and message and logs the message in gs.info if debug and method isn't in noDebugMethods
     * Parameters: [string] - methodName: name of method calling log.
                   [string] - msg: message being called in log.
     * Returns: None.
     */

    log: function(methodName, msg) {
        if (this.debug && this.noDebugMethods.indexOf(methodName) === -1) {
            gs.info('[Magic Utils - ' + methodName + '] ' + msg);
        }
    },

    convertResponse: function(inputs) {
        var utils = new x_759224_magic_c_0.symbology_utils();
        var body = JSON.parse(inputs.response);
        var nBody;
        if (body.data != null) {
            nBody = body.data[0]; // get the first card object
        } else {
            (nBody = body);
        }
        nBody.foiling = inputs.foiling;

        // Format legalities with game changer support
        if (nBody.legalities) {
            var gameChanger = nBody.game_changer;
            nBody.legalities = utils.formatLegalities(nBody.legalities, gameChanger);
        }

        if (nBody.colors && Array.isArray(nBody.colors)) {
            nBody.colors = nBody.colors.join(",");
        }
        var foiling = inputs.foiling.toString()
        // Manage faces
        if (nBody.card_faces && Array.isArray(nBody.card_faces)) {
            if (!nBody.image_uris) {
                nBody.card_faces = utils.convertImageUrisToHtml(nBody, true);
            } else {
                nBody.image_uris = utils.convertImageUrisToHtml(nBody, false);
            }

            for (var face = 0; face < nBody.card_faces.length; face++) {
                var thisFace = nBody.card_faces[face];

                // Convert oracle text to contain symbols
                if (typeof thisFace.oracle_text === 'string') {
                    thisFace.oracle_text = utils.convertSymbolsToImages(thisFace.oracle_text);
                }

                // Convert mana cost to contain symbols
                if (typeof thisFace.mana_cost === 'string') {
                    thisFace.mana_cost = utils.convertSymbolsToImages(thisFace.mana_cost);
                }

                // Convert colors array to comma-separated string
                if (Array.isArray(thisFace.colors)) {
                    thisFace.colors = thisFace.colors.join(",");
                }
            }

        } else if (typeof nBody.oracle_text === 'string' && typeof nBody.mana_cost === 'string') {
            // If it's a single-faced card
            nBody.oracle_text = utils.convertSymbolsToImages(nBody.oracle_text);
            nBody.mana_cost = utils.convertSymbolsToImages(nBody.mana_cost);

            // Set colors
            if (nBody.colors && Array.isArray(nBody.colors)) {
                nBody.colors = nBody.colors.join(",");
            }

            if (nBody.image_uris) {
                nBody.image_uris = utils.convertImageUrisToHtml(nBody, false);
            }
        }

        // These keys are always outside of the faces array
        if (nBody.color_identity && Array.isArray(nBody.color_identity)) {
            nBody.color_identity = nBody.color_identity.join(",");
        }

        if (nBody.produced_mana && Array.isArray(nBody.produced_mana)) {
            nBody.produced_mana = nBody.produced_mana.join(",");
        }
        // Set keywords
        if (nBody.keywords && Array.isArray(nBody.keywords)) {
            var keywords = [];
            var c = 0;
            var input = nBody.keywords;
            var l = nBody.keywords.length;
            while (c < l) {
                var keywordGr = new GlideRecord(this.KEYWORDS);
                keywordGr.get('name', input[c]);
                if (keywordGr)
                    keywords.push(keywordGr.getUniqueValue());
                c++;
            }
            nBody.keywords = keywords.join(',');
        }

        // Set the modified card object as the new response
        return nBody;
    },

    /**
     * Description: Takes in set_id and returns the set record on the system
     * Parameters: [string] - set_id: the string id used to identify a set
     * Returns: [object]: Set record object.
     */

    getSetRecord: function(set_id) {
        var setGR = new GlideRecord(this.SETS);
        return setGR.get('id', set_id);
    },

    /* Description: Creates a owned card record for the provided card and user with the qty or default to 1
     * Parameters: [string] - card: sys id of the card to be associated to the user
     			   [string] - user: sys id of the user the card will be associated to
				   [integer] - qty: Quantity of the cards the user has, optional param defaults to 1
     * Returns: [object]: Contains a success flag and the record if success, or msg if failure
     */

    createOwnedRecord: function(card, user, qty) {
        try {
            var newOwned = new GlideRecord(this.OWNED_CARDS);
            newOwned.initialize();
            newOwned.setValue('card', card);
            newOwned.setValue('owner', user);
            newOwned.setvalue('quantity', qty || 1);
            newOwned.insert();

            return {
                success: true,
                record: newOwned
            };
        } catch (ex) {
            return {
                success: false,
                msg: ex.message()
            };
        }
    },

    /* Description: Creates a token record for the provided name and scryfall ID 
     * Parameters: [string] - name: Name of the token to be created
     			   [string] - id: Scryfall ID of the token. Used for generating association later
     * Returns: [object]: Contains a success flag and the record if success, or msg if failure
     */

    createToken: function(name, id) {
        try {
            var newToken = new GlideRecord(this.CARDS);
            newToken.initialize();
            newToken.setValue('name', name);
            newToken.setValue('scryfall_id', id);
            newToken.insert();

            return {
                success: true,
                record: newToken
            };
        } catch (ex) {
            return {
                success: false,
                msg: ex.message()
            };
        }
    },

    /** 
    * Description: Creates a token association record for the provided card and token records
	* Parameters: [object] - card: Card GlideRecord object
				  [object] - token: Token Card GlideRecord object
	* Returns: [object]: Contains a success flag and the record if success, or msg if failure
	*/

    createTokenAssociation: function(card, token) {
        try {
            var newTokenAssociation = new GlideRecord(this.TOKEN_ASSOCIATION);
            newTokenAssociation.initialize();
            newTokenAssociation.setValue('token', token.getUniqueValue());
            newTokenAssociation.setValue('card', card.sys_id);
            newTokenAssociation.insert();

            return {
                success: true,
                record: newTokenAssociation
            };
        } catch (ex) {
            return {
                success: false,
                msg: ex.message()
            };
        }
    },

    /**
     * Description: Takes in either a object or sys_id of the card and token and returns the number of associations for them
     * Parameters: [object / string] - card: Either a GlideRecord object or sys_id of the card record
     * 			   [object / string] - token: Either a GlideRecord object or sys_id of the token record
     * Returns: [integer]: The number of associations for the provided card and token
     */

    getTokenAssociationCount: function(card, token) {
        var associationGR = new GlideRecord(this.TOKEN_ASSOCIATION);

        var cardSysId = (card && typeof card.getUniqueValue === 'function') ? card.getUniqueValue() : card;
        var tokenSysId = (token && typeof token.getUniqueValue === 'function') ? token.getUniqueValue() : token;

        if (!cardSysId || !tokenSysId)
            return 0;

        associationGR.addQuery('card', cardSysId);
        associationGR.addQuery('token', tokenSysId);
        associationGR.query();

        return associationGR.getRowCount();
    },

    /**
     * Description: Takes in an image string (generally the html one from a card) and grabs the source link of the image. If there isn't one, sets it to be the default mtg backing.
     * Parameters: [string] - img: The value from the image field on a card.
     * Returns: [string]: source url for the image, or the default back image.
     */

    getImgSrc: function(img) {
        var regex = /<img[^>]*\s+src=["']([^"']+)["']/i;
        if (img)
            var match = img.match(regex);
        var retval = '';
        if (match && match[1]) {
            retval = match[1];
        } else {
            retval = 'x_759224_magic_c_0.card-back.png';
        }
        return retval;
    },

    /**
     * Description: Takes in HTML from an HTML field and returns the content inside without HTML. 
     * Parameters: [string] - html: The HTML from a HTML field.
     * Returns: [string]: Contents inside of the HTML.
     */

    stripHTML: function(html) {
        return html.replace(/<[^>]*>/g, '');
    },

    /**
     * Description: Takes in a comma separated string of colors and converts them to the full color name. 
     * Parameters: [string]: colors - The colors field (ex: W,U = White, Blue).
     * Returns: [string]: Comma separated string of colors in the form of sys_ids since the fields use a reference to a colors table instead of specified choices.
     */

    convertColors: function(colors) {
        if (!colors) return "";

        var order = ['W', 'U', 'B', 'R', 'G', 'C'];

        return colors
            .toUpperCase()
            .split('')
            .filter(c => this.constants.colors[c]) // only valid color keys
            .sort((a, b) => order.indexOf(a) - order.indexOf(b))
            .map(c => this.constants.colors[c]) // convert to sys_ids
            .join(',');

    },
    /**
     * Description: Takes in an id string for a card. 
     * Parameters: [string] - id: The sys id of the card record.
     * Returns: [Array] - relArr: An array of JSON objects containg the related card name and image.
     */

    getRelatedCards: function(id) {
        var relGR = new GlideRecord(this.TOKEN_ASSOCIATION);
        relGR.addQuery('card', id);
        relGR.query();
        var relArr = [];

        while (relGR.next()) {
            var token = relGR.token.getRefRecord();
            relObj = {
                name: token.getValue('name'),
                image: this.getImgSrc(token.getValue('face_one_image')),
                is_foil: token.getValue('foiling') != 'none'
            };
            relArr.push(relObj);
        }
        return relArr;
    },

    /**
     * Description: Takes in an name string for a card. 
     * Parameters: [string] - name: The name of the card record.
     * Returns: [object] - cardData: JSON object containing all the data from the card record.
     */

    getOtherPrintings: function(name) {
        var cardGR = new GlideRecord(this.CARDS);
        cardGR.addQuery('token', false);
        cardGR.addQuery('name', name);
        cardGR.query();
        printingArr = [];

        while (cardGR.next()) {
            printingObj = {
                image: this.getImgSrc(cardGR.getValue('face_one_image')),
                price: cardGR.getValue('price'),
                sets: cardGR.getDisplayValue('sets'),
                is_foil: cardGR.getValue('foiling') != 'none'
            };
            printingArr.push(printingObj);
        }
        return printingArr;
    },

    /** 
    * Description: Takes in a card GlideRecord and a response object
    * Parameters: [GlideRecord]: Card - card record to update values of
    			  [Object]: Resp - Object to pull data from to set on the card
    * Returns: 
    */

    setCardValues: function(card, resp) {
        try {
            var outputs = {};
            // Fields to always populate
            var topFields = this.GENERAL_FIELDS;

            topFields.forEach(function(field) {
                if (resp[field] !== undefined && resp[field] !== null) {
                    card.setValue(field, resp[field]);
                }
            });

            // Set Color Identity
            if (resp.color_identity) {
                card.setValue('color_identity', this.convertColors(resp.color_identity));
            } else {
                card.setValue('color_identity', this.constants.colors['C']);
            }

            // Set Scryfall ID
            if (resp.id && !card.getValue('scryfall_id')) {
                card.setValue('scryfall_id', resp.id);
            }

            // Set Oracle ID
            if (resp.oracle_id && !card.getValue('oracle_id')) {
                card.setValue('oracle_id', resp.oracle_id);
            }

            // Set token to true if type line contains token
            if (resp.type_line.toLowerCase().indexOf('token') !== -1) {
                card.setValue('token', 'true');
            }

            // Set set if not currently populated
            if (!card.sets) {
                var setsGR = new GlideRecord(this.SETS);
                setsGR.get('id', resp.set);
                if (setsGR) {
                    card.setValue('sets', setsGR.getUniqueValue());
                }
            }

            // Set CN if not currently populated
            if (!card.collector_number) {
                card.setValue('collector_number', resp.collector_number);
            }

            // Related URIs (links)
            if (resp.related_uris) {
                if (resp.related_uris.edhrec) card.setValue('edhrec', resp.related_uris.edhrec);
                if (resp.related_uris.gatherer) card.setValue('gatherer', resp.related_uris.gatherer);
            }

            if (resp.purchase_uris) {
                if (resp.purchase_uris.tcgplayer) card.setValue('tcgplayer_purchase', resp.purchase_uris.tcgplayer);
                if (resp.purchase_uris.cardhoarder) card.setValue('cardhoarder_purchase', resp.purchase_uris.cardhoarder);
                if (resp.purchase_uris.cardmarket) card.setValue('cardmarket_purchase', resp.purchase_uris.cardmarket);
            }

            // Legality
            if (resp.legalities) {
                for (var format in resp.legalities) {
                    var fieldName = format + '_legality';
                    if (card.isValidField(fieldName)) {
                        card.setValue(fieldName, resp.legalities[format]);
                    }
                }
            }

            // URI Link
            if (resp.uri) {
                card.setValue('api_link', resp.uri);
            }

            // Price
            if (resp.prices) {
                var foiling = card.getValue('foiling'); // "none", "foil", or "etched"
                var priceKey = 'usd';
                if (foiling === 'foil') priceKey = 'usd_foil';
                else if (foiling === 'etched') priceKey = 'usd_etched';

                var newPrice = parseFloat(resp.prices[priceKey]);
                var currentPrice = parseFloat(card.getValue('price'));
                var priceChange = newPrice - currentPrice;

                card.setValue('price', newPrice.toFixed(2));
                if (priceChange != 0)
                    card.setValue('price_change', priceChange);
            }

            // Multi-faced card logic
            if (Array.isArray(resp.card_faces) && resp.card_faces.length > 1) {
                var front = resp.card_faces[0];
                var back = resp.card_faces[1];
                card.setValue('is_multi_faced', true);

                if (front) {
                    if (front.name) card.setValue('face_one_name', front.name);
                    if (front.flavor_name) card.setValue('face_one_flavor_name', front.flavor_name);
                    if (front.oracle_text) card.setValue('face_one_oracle_text', front.oracle_text);
                    if (front.type_line) card.setValue('type_line', front.type_line);
                    if (front.mana_cost) card.setValue('face_one_mana_cost', front.mana_cost);
                    if (front.colors) card.setValue('face_one_colors', this.convertColors(front.colors));
                    if (front.artist) card.setValue('face_one_artist', front.artist);
                    if (front.loyalty) card.setValue('face_one_loyalty', front.loyalty);
                    if (front.power) card.setValue('face_one_power', front.power);
                    if (front.toughness) card.setValue('face_one_toughness', front.toughness);
                    if (front.produced_mana) card.setValue('face_one_produced_mana', this.convertColors(front.produced_mana));
                    if (front.flavor_text) card.setValue('face_one_flavor_text', front.flavor_text);
                    if (front.image_uris.normal) card.setValue('face_one_image', front.image_uris.normal);
                    if (front.image_uris.normal) card.setValue('face_one_image', front.image_uris.normal);
                }

                if (back) {
                    if (back.name) card.setValue('face_two_name', back.name);
                    if (back.flavor_name) card.setValue('face_two_flavor_name', back.flavor_name);
                    if (back.oracle_text) card.setValue('face_two_oracle_text', back.oracle_text);
                    if (back.type_line) card.setValue('face_two_type_line', back.type_line);
                    if (back.mana_cost) card.setValue('face_two_mana_cost', back.mana_cost);
                    if (back.colors) card.setValue('face_two_colors', this.convertColors(back.colors));
                    if (back.artist) card.setValue('face_two_artist', back.artist);
                    if (back.loyalty) card.setValue('face_two_loyalty', back.loyalty);
                    if (back.power) card.setValue('face_two_power', back.power);
                    if (back.toughness) card.setValue('face_two_toughness', back.toughness);
                    if (back.produced_mana) card.setValue('face_two_produced_mana', this.convertColors(back.produced_mana));
                    if (back.flavor_text) card.setValue('face_two_flavor_text', back.flavor_text);
                    if (back.image_uris.normal) card.setValue('face_two_image', back.image_uris.normal);
                    if (back.image_uris.normal) card.setValue('face_two_image', back.image_uris.normal);
                }
            }

            // Single-faced card logic â†’ populate face_one_* fields from top-level
            else {
                if (resp.flavor_name) card.setValue('face_one_flavor_name', resp.flavor_name);
                if (resp.oracle_text) card.setValue('face_one_oracle_text', resp.oracle_text);
                if (resp.type_line) card.setValue('face_one_type_line', resp.type_line);
                if (resp.mana_cost) card.setValue('face_one_mana_cost', resp.mana_cost);
                if (resp.colors) card.setValue('face_one_colors', this.convertColors(resp.colors));
                if (resp.artist) card.setValue('face_one_artist', resp.artist);
                if (resp.loyalty) card.setValue('face_one_loyalty', resp.loyalty);
                if (resp.power) card.setValue('face_one_power', resp.power);
                if (resp.toughness) card.setValue('face_one_toughness', resp.toughness);
                if (resp.produced_mana) card.setValue('face_one_produced_mana', this.convertColors(resp.produced_mana));
                if (resp.flavor_text) card.setValue('face_one_flavor_text', resp.flavor_text);
                if (resp.image_uris.normal) card.setValue('face_one_image', resp.image_uris.normal);
            }
            // Update card record
            card.update();

            // Generate Historical Prices
            this.generateHistoricalPrices(card);
            // Generate Tokens
            this.generateTokens(card, resp);

            // Update was a success
            outputs.status = 'success';
            outputs.card = card;
        } catch (err) {
            gs.error('Card population error: ' + err.message);
            outputs.status = 'error: ' + err.message;
            outputs.card = card;
        }
        return outputs;
    },

    /*
     * Description: Generates a historical price record for the provided card if one hasn't been made in the price wait period
     * Parameters: [Object]: Card - card record
     * Returns: Creates a historical card price record
     */

    generateHistoricalPrices: function(card) {

        // Generate Historical Price record
        var historicalPriceGr = new GlideRecord(this.HISTORICAL_PRICES);
        historicalPriceGr.addEncodedQuery('card=' + card.sys_id + '^sys_created_onRELATIVEGT@hour@ago@' + this.HISTORIC_PRICE_WAIT);
        historicalPriceGr.query();
        // Historical price is older than 32 hours ago and the current price is greater than 0.
        if (historicalPriceGr.getRowCount() == 0 && card.price > 0) {
            var newRec = new GlideRecord(this.HISTORICAL_PRICES);
            newRec.initialize();
            newRec.setValue('card', card.sys_id);
            newRec.setValue('price', card.price);
            newRec.insert();
        }
    },

    /*
     * Description: Generates any tokens that are part of an api response if they don't exist already and create a token association if one doesn't exist between the token and
     * Parameters: [Object]: Card - card record
     *             [Object]: Resp - api response from scryfall
     * Returns: Creates any tokens / token associations for the provided card / response combo
     */

    generateTokens: function(card, resp) {
        // Generate Tokens
        if (resp.all_parts) {
            var c = 0;
            // Loop through all parts
            while (c < resp.all_parts.length) {
                // If the part is token
                if (resp.all_parts[c].component == 'token' && resp.all_parts[c].id != card.scryfall_id) {
                    var tokenGR = new GlideRecord(this.CARDS);
                    tokenGR.addQuery('scryfall_id', resp.all_parts[c].id);
                    tokenGR.query();
                    // If the token doesn't exist in the system
                    if (!tokenGR.next()) {
                        // Create token
                        var newToken = this.createToken(resp.all_parts[c].name, resp.all_parts[c].id);
                        // Create token association record
                        if (!card.face_one_type_line.includes('token')) { // Creates an association if card is not a token
                            this.createTokenAssociation(card, newToken.record);
                        }
                    } else { // Token exists, check if there's an association
                        var associations = this.getTokenAssociationCount(card, tokenGR);
                        if (associations == 0 && !card.face_one_type_line.includes('token')) { // If no association exists, create one
                            this.createTokenAssociation(card, tokenGR);
                        }
                    }
                }
                c++;
            }
        }
    },

    /**
     * Description: Takes in an id string for a card, and builds out an object containing the data
     * Parameters: [string] - id: The sys id of the card record.
     * Returns: [object] - cardData: JSON object containing all the data from the card record.
     */

    getCardData: function(id) {
        var cardGR = new GlideRecord(this.CARDS);
        cardGR.get(id); // Get the card record
        var cardData = {
            legality: { // Legalities for the card
                alchemy: this.stripHTML(cardGR.getValue('alchemy_legality')) == 'Legal' || false,
                brawl: this.stripHTML(cardGR.getValue('brawl_legality')) == 'Legal' || false,
                commander: this.stripHTML(cardGR.getValue('commander_legality')) == 'Legal' || false,
                duel: this.stripHTML(cardGR.getValue('duel_legality')) == 'Legal' || false,
                future: this.stripHTML(cardGR.getValue('future_legality')) == 'Legal' || false,
                gladiator: this.stripHTML(cardGR.getValue('gladiator_legality')) == 'Legal' || false,
                historic: this.stripHTML(cardGR.getValue('historic_legality')) == 'Legal' || false,
                legacy: this.stripHTML(cardGR.getValue('legacy_legality')) == 'Legal' || false,
                modern: this.stripHTML(cardGR.getValue('modern_legality')) == 'Legal' || false,
                oathbreaker: this.stripHTML(cardGR.getValue('oathbreaker_legality')) == 'Legal' || false,
                oldschool: this.stripHTML(cardGR.getValue('oldschool_legality')) == 'Legal' || false,
                pauper_commander: this.stripHTML(cardGR.getValue('paupercommander_legality')) == 'Legal' || false,
                pauper: this.stripHTML(cardGR.getValue('pauper_legality')) == 'Legal' || false,
                penny: this.stripHTML(cardGR.getValue('penny_legality')) == 'Legal' || false,
                pioneer: this.stripHTML(cardGR.getValue('pioneer_legality')) == 'Legal' || false,
                predh: this.stripHTML(cardGR.getValue('predh_legality')) == 'Legal',
                premodern: this.stripHTML(cardGR.getValue('premodern_legality')) == 'Legal' || false,
                standard_brawl: this.stripHTML(cardGR.getValue('standardbrawl_legality')) == 'Legal' || false,
                standard: this.stripHTML(cardGR.getValue('standard_legality')) == 'Legal' || false,
                timeless: this.stripHTML(cardGR.getValue('timeless_legality')) == 'Legal' || false,
                vintage: this.stripHTML(cardGR.getValue('vintage_legality')) == 'Legal' || false
            },
            flags: { // Card flags
                is_foil: cardGR.getValue('foiling') != 'none',
                is_reserved: cardGR.getValue('reserved_list') == '1',
                is_gc: cardGR.getValue('game_changer') == '1',
                is_token: cardGR.getValue('token') == '1',
                is_multifaced: cardGR.getValue('is_multi_faced') == '1',
                // Deck card flags
                is_commander: false,
                is_maybeboard: false,
                is_sideboard: false,
                is_flipped: false
            },
            face_one: { // Face one data
                artist: cardGR.getValue('face_one_artist'),
                colors: cardGR.getDisplayValue('face_one_colors'),
                flavor_name: cardGR.getValue('face_one_flavor_name'),
                flavor_text: cardGR.getValue('face_one_flavor_text'),
                image: this.getImgSrc(cardGR.getValue('face_one_image')),
                loyalty: cardGR.getValue('face_one_loyalty'),
                mana_cost: cardGR.getValue('face_one_mana_cost'),
                name: cardGR.getValue('face_one_name'),
                oracle_text: cardGR.getValue('face_one_oracle_text'),
                power: cardGR.getValue('face_one_power'),
                toughness: cardGR.getValue('face_one_toughness'),
                type_line: cardGR.getValue('face_one_type_line')
            },
            face_two: { // Face two data
                artist: cardGR.getValue('face_two_artist'),
                colors: cardGR.getDisplayValue('face_two_colors'),
                flavor_name: cardGR.getValue('face_two_flavor_name'),
                flavor_text: cardGR.getValue('face_two_flavor_text'),
                image: this.getImgSrc(cardGR.getValue('face_two_image')),
                loyalty: cardGR.getValue('face_two_loyalty'),
                mana_cost: cardGR.getValue('face_two_mana_cost'),
                name: cardGR.getValue('face_two_name'),
                oracle_text: cardGR.getValue('face_two_oracle_text'),
                power: cardGR.getValue('face_two_power'),
                toughness: cardGR.getValue('face_two_toughness'),
                type_line: cardGR.getValue('face_two_type_line')
            },
            links: { // Links associated to the card
                edhrec: cardGR.getValue('edhrec'),
                gatherer: cardGR.getValue('gatherer'),
                cardhoarder: cardGR.getValue('cardhoarder_purchase'),
                cardmarket: cardGR.getValue('cardmarket_purchase'),
                tcgplayer: cardGR.getValue('tcgplayer_purchase')
            },
            counters: { // Counters availble to put on cards.
                generic: 0,
                plusOne: 0,
                minusOne: 0,
                loyalty: cardGR.getValue('face_one_loyalty') || cardGR.getValue('face_two_loyalty') || 0,
                lore: 0,
                time: 0,
                shield: 0,
                charge: 0,
                lifelink: 0,
                haste: 0,
                indestructible: 0,
                flying: 0,
                deathtouch: 0,
                menace: 0,
                trample: 0,
                firstStrike: 0,
                doubleStrike: 0,
                reach: 0,
                vigilance: 0
            },
            related_cards: this.getRelatedCards(id),
            printings: this.getOtherPrintings(cardGR.getValue('name')),
            price: cardGR.getValue('price'),
            quantity: 0,
            name: cardGR.getValue('name'),
            cmc: cardGR.getValue('cmc'),
            colors: cardGR.getDisplayValue('color_identity'),
            sets: cardGR.getDisplayValue('sets'),
            cn: cardGR.getValue('collector_number')
        };
        return cardData;
    },

    type: 'magic_utils'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-05-31 01:08:27</sys_created_on>
        <sys_id>7b63953c936a0210a066fa497bba10db</sys_id>
        <sys_mod_count>162</sys_mod_count>
        <sys_name>magic_utils</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sys_script_include_7b63953c936a0210a066fa497bba10db</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-02-13 05:32:43</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>7b63953c936a0210a066fa497bba10db</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-11-19 00:52:03</sys_created_on>
        <sys_id>7c028bc8c3021210b7cebd73e401319a</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-11-19 00:52:03</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
