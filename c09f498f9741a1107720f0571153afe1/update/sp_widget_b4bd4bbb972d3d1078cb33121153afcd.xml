<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $element, $timeout, $location, $window) {
	var c = this;

	c.playerHealth = c.data.playerHealth || 20;
	c.cards = []; // All draggable cards (commanders + hand + any new cards)
	let keydownListenerAdded = false;

	var draggingCard = null;
	var offsetX = 0,
			offsetY = 0;

	// Card metrics
	var CARD_WIDTH = 190;
	var CARD_HEIGHT = 264;
	var DEFAULT_GAP_X = 10;

	c.modifyHealth = function(amount) {
		$scope.$applyAsync(function() {
			c.playerHealth = Math.max(0, c.playerHealth + amount);
		});
	};

	// Helper: DOM rects for zones
	function getZoneRects() {
		var playmatEl = $element[0];

		function safeRect(selector) {
			var el = playmatEl.querySelector(selector);
			return el ? el.getBoundingClientRect() : null;
		}
		return {
			playmat: playmatEl.getBoundingClientRect(),
			hand: safeRect('.hand'),
			battlefield: safeRect('.battlefield'),
			command: safeRect('.command-zone'),
			sideboard: safeRect('.sideboard-zone'),
			graveyard: safeRect('.graveyard'),
			exile: safeRect('.exile')
		};
	}

	function pointInRect(x, y, rect) {
		return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
	}

	// Helper functions to move cards between zones
	function moveCardToZone(card, targetZone, position) {
		// Remove card from all zones first
		if (c.data.showCommandZone) removeFromZone(card, 'command');
		if (c.data.showSideboardZone) removeFromZone(card, 'sideboard');
		removeFromZone(card, 'hand');
		removeFromZone(card, 'battlefield');
		removeFromZone(card, 'graveyard');
		removeFromZone(card, 'exile');

		if (targetZone != 'battlefield')
			card.isTapped = false;
		// Add card to target zone
		if (targetZone === 'command' && c.data.showCommandZone) {
			c.data.commanders.push(card);
		} else if (targetZone === 'sideboard' && c.data.showSideboardZone) {
			c.data.sideboard.push(card);
		} else if (targetZone === 'hand') {
			c.data.hand.push(card);
		} else if (targetZone === 'battlefield') {
			if (position) {
				card.left = position.x;
				card.top = position.y;
			}
			c.data.battlefield.push(card);
		} else if (targetZone === 'graveyard') {
			c.data.graveyard.push(card);
		} else if (targetZone === 'exile') {
			c.data.exile.push(card);
		}

		// Update the c.cards array to reflect the new zone assignments
		c.cards = (c.data.showCommandZone ? c.data.commanders : [])
			.concat(c.data.hand)
			.concat(c.data.battlefield)
			.concat(c.data.graveyard)
			.concat(c.data.exile)
			.concat(c.data.showSideboardZone ? c.data.sideboard : []);
	}

	function removeFromZone(card, zone) {
		var zoneArray;
		if (zone === 'command' && c.data.showCommandZone) zoneArray = c.data.commanders;
		else if (zone === 'sideboard' && c.data.showSideboardZone) zoneArray = c.data.sideboard;
		else if (zone === 'hand') zoneArray = c.data.hand;
		else if (zone === 'battlefield') zoneArray = c.data.battlefield;
		else if (zone === 'graveyard') zoneArray = c.data.graveyard;
		else if (zone === 'exile') zoneArray = c.data.exile;

		if (zoneArray) {
			var idx = zoneArray.indexOf(card);
			if (idx !== -1) zoneArray.splice(idx, 1);
		}
	}
	// Gets the zone that the card is currently within
	function getCardZone(card) {
		if (c.data.showCommandZone && c.data.commanders.indexOf(card) !== -1) return 'command';
		if (c.data.showSideboardZone && c.data.sideboard.indexOf(card) !== -1) return 'sideboard';
		if (c.data.hand.indexOf(card) !== -1) return 'hand';
		if (c.data.battlefield.indexOf(card) !== -1) return 'battlefield';
		if (c.data.graveyard.indexOf(card) !== -1) return 'graveyard';
		if (c.data.exile.indexOf(card) !== -1) return 'exile';
		return null;
	}

	// Snap card to graveyard zone
	function snapToGraveyard(card) {
		var rects = getZoneRects();
		var playmatRect = rects.playmat;
		var graveyardRect = rects.graveyard;

		// Center the card in the graveyard zone
		var zoneLeft = graveyardRect.left - playmatRect.left;
		var zoneTop = graveyardRect.top - playmatRect.top;
		card.left = Math.round(zoneLeft + (graveyardRect.width - CARD_WIDTH) / 2);
		card.top = Math.round(zoneTop + (graveyardRect.height - CARD_HEIGHT) / 2);
	}

	// Snap card to exile zone
	function snapToExile(card) {
		var rects = getZoneRects();
		var playmatRect = rects.playmat;
		var exileRect = rects.exile;

		// Center the card in the exile zone
		var zoneLeft = exileRect.left - playmatRect.left;
		var zoneTop = exileRect.top - playmatRect.top;
		card.left = Math.round(zoneLeft + (exileRect.width - CARD_WIDTH) / 2);
		card.top = Math.round(zoneTop + (exileRect.height - CARD_HEIGHT) / 2);
	}

	// Snap card to command zone
	function snapToCommand(card) {
		var rects = getZoneRects();
		var playmatRect = rects.playmat;
		var commandRect = rects.command;

		// Center the card in the command zone
		var zoneLeft = commandRect.left - playmatRect.left;
		var zoneTop = commandRect.top - playmatRect.top;
		card.left = Math.round(zoneLeft + (commandRect.width - CARD_WIDTH) / 2);
		card.top = Math.round(zoneTop + (commandRect.height - CARD_HEIGHT) / 2);
	}

	// Snap card to sideboard zone
	function snapToSideboard(card) {
		var rects = getZoneRects();
		var playmatRect = rects.playmat;
		var sideboardRect = rects.sideboard;
		if (!sideboardRect) return;
		var zoneLeft = sideboardRect.left - playmatRect.left;
		var zoneTop = sideboardRect.top - playmatRect.top;
		card.left = Math.round(zoneLeft + (sideboardRect.width - CARD_WIDTH) / 2);
		card.top = Math.round(zoneTop + (sideboardRect.height - CARD_HEIGHT) / 2);
	}

	// Layout all cards that are in the hand zone (by membership), left-to-right.
	c.layoutHand = function() {
		var rects = getZoneRects();
		var playmatRect = rects.playmat;
		var handRect = rects.hand;

		var leftStart = handRect.left - playmatRect.left + 10; // small inner padding
		var topPos = handRect.bottom - playmatRect.top - CARD_HEIGHT - 10;
		var availableWidth = handRect.width - 20; // padding on both sides

		// Get all cards that are actually in hand zone (from hand array)
		var handCards = c.data.hand;

		if (handCards.length === 0) return;

		var step;

		// Calculate spacing based on number of cards
		if (handCards.length === 1) {
			// Single card - center it
			step = 0;
			leftStart = leftStart + (availableWidth - CARD_WIDTH) / 2;
		} else if (handCards.length * (CARD_WIDTH + DEFAULT_GAP_X) <= availableWidth) {
			// Enough space for generous spacing
			step = CARD_WIDTH + DEFAULT_GAP_X;
		} else {
			// Need to compress - calculate overlap
			var totalCardsWidth = handCards.length * CARD_WIDTH;
			var neededOverlap = (totalCardsWidth - availableWidth) / Math.max(1, handCards.length - 1);

			// For extreme cases (30+ cards), allow heavy overlap but ensure minimum visibility
			var minVisibleWidth = Math.max(20, CARD_WIDTH * 0.1); // At least 10% of card width visible
			var maxOverlap = CARD_WIDTH - minVisibleWidth;

			var overlapAmount = Math.min(maxOverlap, neededOverlap);
			step = CARD_WIDTH - overlapAmount;
		}

		// Position ALL hand cards in order to ensure proper fanning
		handCards.forEach(function(card, index) {
			card.left = Math.round(leftStart + index * step);
			card.top = Math.round(topPos);
		});
	};

	// Draw from the top of the library; new card goes to LEFTMOST of the hand.
	c.drawCard = function() {
		if (c.data.library.length === 0) return;

		var drawnCard = c.data.library.shift();

		// Add card to hand
		c.data.hand.push(drawnCard);
		c.cards.push(drawnCard);

		// Layout hand to position the new card
		c.layoutHand();

		// Update DOM positions for hand cards
		$timeout(function() {
			var playmatEl = $element[0];
			var cardsEls = playmatEl.querySelectorAll('.draggable-card');

			cardsEls.forEach(function(cardEl, i) {
				var card = c.cards[i];
				if (card && c.data.hand.indexOf(card) !== -1) {
					cardEl.style.left = card.left + 'px';
					cardEl.style.top = card.top + 'px';
				}
			});
			c.renderCards();
		});
	};

	// Untap all cards
	c.untapAll = function() {
		$scope.$applyAsync(function() {
			c.data.battlefield.forEach(function(card) {
				if (card.isTapped) {
					card.isTapped = false;
				}
			});
			c.renderCards();
		});
	};

	// Tap all cards
	c.tapAll = function() {
		$scope.$applyAsync(function() {
			c.data.battlefield.forEach(function(card) {
				if (!card.isTapped) {
					card.isTapped = true;
				}
			});
			c.renderCards();
		});
	};

	// New turn
	c.newTurn = function(){
		c.untapAll();
		c.drawCard();
		c.data.turn +=1;
	}

	c.renderCards = function() {
		var playmatEl = $element[0];
		var rects = getZoneRects();
		var playmatRect = rects.playmat;
		var commandRect = rects.command;
		//var sideboardRect = rects.sideboard;

		// Position commanders in command zone
		if (c.data.showCommandZone) {
			c.data.commanders.forEach(function(card) {
				if (card.left === undefined || card.top === undefined) {
					var zoneLeft = commandRect.left - playmatRect.left;
					var zoneTop = commandRect.top - playmatRect.top;
					card.left = Math.round(zoneLeft + (commandRect.width - CARD_WIDTH) / 2);
					card.top = Math.round(zoneTop + (commandRect.height - CARD_HEIGHT) / 2);
				}
			});
		}

		// Position graveyard cards
		c.data.graveyard.forEach(function(card) {
			if (card.left === undefined || card.top === undefined) {
				snapToGraveyard(card);
			}
		});

		// Position exile cards
		c.data.exile.forEach(function(card) {
			if (card.left === undefined || card.top === undefined) {
				snapToExile(card);
			}
		});

		// Position sideboard cards
		if (c.data.showSideboardZone) {
			c.data.sideboard.forEach(function(card) {
				if (card.left === undefined || card.top === undefined) {
					snapToSideboard(card);
				}
			});
		}

		// Layout hand cards
		if (c.data.hand.length > 0) {
			c.layoutHand();
		}

		// Apply to DOM and wire DnD
		$timeout(function() {
			var cardsEls = playmatEl.querySelectorAll('.draggable-card');

			cardsEls.forEach(function(cardEl, i) {
				cardEl.style.position = 'absolute';

				var card = c.cards[i];
				if (!card) return;

				// Only update position if the card has a defined position and it's different from current DOM position
				// This prevents overwriting positions of cards that have been manually positioned (like on battlefield)
				if (card.left !== undefined && card.top !== undefined) {
					var currentLeft = parseInt(cardEl.style.left) || 0;
					var currentTop = parseInt(cardEl.style.top) || 0;

					// Only update if the position has actually changed (with some tolerance for rounding)
					if (Math.abs(currentLeft - card.left) > 2 || Math.abs(currentTop - card.top) > 2) {
						cardEl.style.left = card.left + 'px';
						cardEl.style.top = card.top + 'px';
					}
				}

				if (card.isTapped) cardEl.classList.add('rotated');
				else cardEl.classList.remove('rotated');

				// Clean old handlers
				cardEl.onmousedown = null;
				cardEl.onmouseup = null;
				cardEl.ondblclick = null;
				document.onmousemove = null;

				cardEl.addEventListener('mousedown', function(e) {
					draggingCard = card;
					var currentRects = getZoneRects(); // refresh per interaction
					var localPlaymatRect = currentRects.playmat;

					offsetX = e.clientX - card.left;
					offsetY = e.clientY - card.top;
					cardEl.style.cursor = 'grabbing';
					cardEl.style.transition = 'none';
					e.preventDefault();

					document.onmousemove = function(e2) {
						if (!draggingCard) return;

						// Safety check: ensure draggingCard is still in the cards array
						if (c.cards.indexOf(draggingCard) === -1) {
							draggingCard = null;
							return;
						}

						draggingCard.left = e2.clientX - offsetX;
						draggingCard.top = e2.clientY - offsetY;

						cardEl.style.left = draggingCard.left + 'px';
						cardEl.style.top = draggingCard.top + 'px';
					};

					document.onmouseup = function() {
						if (!draggingCard) return;

						// Safety check: ensure draggingCard is still in the cards array
						if (c.cards.indexOf(draggingCard) === -1) {
							draggingCard = null;
							return;
						}

						// Determine drop zone by card center in page coords
						var centerX = draggingCard.left + CARD_WIDTH / 2 + localPlaymatRect.left;
						var centerY = draggingCard.top + CARD_HEIGHT / 2 + localPlaymatRect.top;

						var dropZone = null;
						var rectsNow = getZoneRects();
						if (pointInRect(centerX, centerY, rectsNow.hand)) dropZone = 'hand';
						else if (pointInRect(centerX, centerY, rectsNow.battlefield)) dropZone = 'battlefield';
						else if (pointInRect(centerX, centerY, rectsNow.command)) dropZone = 'command';
						else if (pointInRect(centerX, centerY, rectsNow.graveyard)) dropZone = 'graveyard';
						else if (pointInRect(centerX, centerY, rectsNow.exile)) dropZone = 'exile';
						else if (pointInRect(centerX, centerY, rectsNow.sideboard)) dropZone = 'sideboard';

						$scope.$applyAsync(function() {
							if (dropZone === 'hand') {
								moveCardToZone(draggingCard, 'hand');
								// Reset position so layoutHand can position it properly
								draggingCard.left = undefined;
								draggingCard.top = undefined;
								c.layoutHand();
							} else if (dropZone === 'graveyard') {
								moveCardToZone(draggingCard, 'graveyard');
								snapToGraveyard(draggingCard);
							} else if (dropZone === 'exile') {
								moveCardToZone(draggingCard, 'exile');
								snapToExile(draggingCard);
							} else if (dropZone === 'command') {
								moveCardToZone(draggingCard, 'command');
								snapToCommand(draggingCard);
							} else if (dropZone === 'sideboard') {
								moveCardToZone(draggingCard, 'sideboard');
								snapToSideboard(draggingCard);
							} else if (dropZone === 'battlefield') {
								moveCardToZone(draggingCard, 'battlefield', {
									x: draggingCard.left,
									y: draggingCard.top
								});
							} else {
								moveCardToZone(draggingCard, 'battlefield', {
									x: draggingCard.left,
									y: draggingCard.top
								});
							}
						});

						cardEl.style.cursor = 'grab';
						cardEl.style.transition = '';
						//draggingCard = null; // Breaks other logic
						document.onmousemove = null;
						document.onmouseup = null;
					};
				});

				// Remove old dblclick handler if it exists
				if (cardEl._dblclickHandler) {
					cardEl.removeEventListener('dblclick', cardEl._dblclickHandler);
				}

				// Define and bind a new one
				const dblclickHandler = function() {
					$scope.$applyAsync(function() {
						if (c.getCardZone(card) === 'battlefield') {
							card.isTapped = !card.isTapped;
						}
					});
				};

				cardEl.addEventListener('dblclick', dblclickHandler);

				// Store it for next time so we can remove it
				cardEl._dblclickHandler = dblclickHandler;

			});
		});
		if (!keydownListenerAdded) {
			document.addEventListener('keydown', function(event) {
				const key = event.key.toLowerCase();
				const tag = document.activeElement.tagName.toLowerCase();

				// Don't trigger shortcuts if the user is typing in an input or textarea
				if (tag === 'input' || tag === 'textarea') return;

				$scope.$applyAsync(function() {
					if (key === 'd') { // Draw card on "D"
						c.drawCard();
					} else if (key === 's') { // Shuffle deck on "S"
						c.shuffleLibrary();
					} else if (key === 'n') { // New turn on "N"
						c.newTurn();
					} else if (key === 'u') { // Untap everything on "U"
						c.untapAll();
					} else if (key === 't') { // Tap everything on "T"
						c.tapAll();
					}
				});
			});

			keydownListenerAdded = true;
		}

	};

	// On init, check for deck_id in URL and set input if found
	c.$onInit = function() {
		// Extract deck_id from URL if present and set it on input
		var params = new URLSearchParams($window.location.search);
		var deckIdParam = params.get('deck_id');
		if (deckIdParam) {
			c.data.deck_sys_id = deckIdParam;
		}

		// Initialize zone arrays from server data
		c.data.commanders = c.data.commanders || [];
		c.data.hand = c.data.hand || [];
		c.data.library = c.data.library || [];
		c.data.battlefield = c.data.battlefield || [];
		c.data.graveyard = c.data.graveyard || [];
		c.data.exile = c.data.exile || [];
		c.data.sideboard = c.data.sideboard || [];

		// Combine all cards into a single array for rendering
		// Only include visible/draggable zones in c.cards (not library)
		c.cards = (c.data.showCommandZone ? c.data.commanders : [])
			.concat(c.data.hand)
			.concat(c.data.battlefield)
			.concat(c.data.graveyard)
			.concat(c.data.exile)
			.concat(c.data.showSideboardZone ? c.data.sideboard : []);

		// Initialize modal state
		c.showModal = false;
		c.modalTitle = '';
		c.modalCards = [];

		$timeout(function() {
			c.renderCards();
		});
	};

	// Show modal for a specific zone
	c.showZoneModal = function(zoneName) {
		var zoneCards;
		if (zoneName === 'command' && c.data.showCommandZone) {
			zoneCards = c.data.commanders;
		} else if (zoneName === 'sideboard' && c.data.showSideboardZone) {
			zoneCards = c.data.sideboard;
		} else if (zoneName === 'hand') {
			zoneCards = c.data.hand;
		} else if (zoneName === 'battlefield') {
			zoneCards = c.data.battlefield;
		} else if (zoneName === 'graveyard') {
			zoneCards = c.data.graveyard;
		} else if (zoneName === 'exile') {
			zoneCards = c.data.exile;
		} else if (zoneName === 'library') {
			zoneCards = c.data.library; // Show library in order
		} else {
			zoneCards = [];
		}

		c.currentModalZone = zoneName;

		if (zoneCards.length === 0) {
			c.modalTitle = zoneName.charAt(0).toUpperCase() + zoneName.slice(1) + ' (Empty)';
			c.modalCards = [];
		} else {
			c.modalTitle = zoneName.charAt(0).toUpperCase() + zoneName.slice(1) + ' (' + zoneCards.length + ' cards)';
			c.modalCards = zoneCards;
		}

		c.showModal = true;
	};

	// Hide modal
	c.hideZoneModal = function() {
		if (c.currentModalZone === 'library') {
			c.shuffleLibrary();
		}
		c.showModal = false;
		c.modalCards = [];
	};

	c.shuffleLibrary = function() {
		for (let i = c.data.library.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[c.data.library[i], c.data.library[j]] = [c.data.library[j], c.data.library[i]];
		}
	};

	// Make getCardZone available to template
	c.getCardZone = getCardZone;

	// MODAL METHODS //

	// Library context menu state
	c.libraryMenuVisible = false;
	c.libraryMenuX = 0;
	c.libraryMenuY = 0;

	c.showLibraryContextMenu = function(event) {
		event.preventDefault();
		$scope.$applyAsync(function() {
			c.libraryMenuVisible = true;
			c.libraryMenuX = event.clientX;
			c.libraryMenuY = event.clientY;
		});
		// Hide menu on click elsewhere
		$timeout(function() {
			document.addEventListener('mousedown', c.hideLibraryContextMenuOnce, {
				once: true
			});
		});
	};
	// Hides the library context menu
	c.hideLibraryContextMenu = function() {
		c.libraryMenuVisible = false;
	};
	c.hideLibraryContextMenuOnce = function(e) {
		// Only hide if not clicking the menu itself
		if (!e.target.closest('.library-context-menu')) {
			$scope.$applyAsync(function() {
				c.libraryMenuVisible = false;
			});
		}
	};

	// Modal card context menu state
	c.modalCardMenuVisible = false;
	c.modalCardMenuX = 0;
	c.modalCardMenuY = 0;
	c.modalCardMenuCard = null;

	c.showModalCardMenu = function(event, card) {
		event.preventDefault();
		event.stopPropagation();
		$scope.$applyAsync(function() {
			c.modalCardMenuVisible = true;
			c.modalCardMenuX = event.clientX;
			c.modalCardMenuY = event.clientY;
			c.modalCardMenuCard = card;
		});
		$timeout(function() {
			document.addEventListener('mousedown', c.hideModalCardMenuOnce, {
				once: true
			});
		});
	};
	c.hideModalCardMenu = function() {
		c.modalCardMenuVisible = false;
		c.modalCardMenuCard = null;
	};
	c.hideModalCardMenuOnce = function(e) {
		if (!e.target.closest('.modal-card-context-menu')) {
			$scope.$applyAsync(function() {
				c.hideModalCardMenu();
			});
		}
	};
	c.getAvailableZonesForModalCard = function() {
		var zones = ['hand', 'battlefield', 'graveyard', 'exile', 'library'];
		if (c.data.showCommandZone) zones.push('command');
		if (c.data.showSideboardZone) zones.push('sideboard');
		// Remove 'library' if the card is already in the library
		if (c.data.library.indexOf(c.modalCardMenuCard) !== -1) {
			zones = zones.filter(function(z) {
				return z !== 'library';
			});
		}
		return zones.filter(function(z) {
			return c.getCardZone(c.modalCardMenuCard) !== z;
		});
	};
	c.moveModalCardToZone = function(zone) {
		var card = c.modalCardMenuCard;
		if (!card) return;
		// Remove from all zones, including library
		if (c.data.showCommandZone) c.removeFromZone(card, 'command');
		if (c.data.showSideboardZone) c.removeFromZone(card, 'sideboard');
		c.removeFromZone(card, 'hand');
		c.removeFromZone(card, 'battlefield');
		c.removeFromZone(card, 'graveyard');
		c.removeFromZone(card, 'exile');
		// Remove from library if present
		var libIdx = c.data.library.indexOf(card);
		if (libIdx !== -1) c.data.library.splice(libIdx, 1);
		// Add to target zone and snap position if needed
		if (zone === 'command' && c.data.showCommandZone) {
			c.data.commanders.push(card);
			$timeout(function() {
				snapToCommand(card);
			});
		} else if (zone === 'sideboard' && c.data.showSideboardZone) {
			c.data.sideboard.push(card);
			$timeout(function() {
				snapToSideboard(card);
			});
		} else if (zone === 'hand') {
			c.data.hand.push(card);
			card.left = undefined;
			card.top = undefined;
			$timeout(function() {
				c.layoutHand();
			});
		} else if (zone === 'battlefield') {
			c.data.battlefield.push(card);
			// Always snap to center of battlefield
			$timeout(function() {
				var rects = getZoneRects();
				var playmatRect = rects.playmat;
				var battlefieldRect = rects.battlefield;
				if (battlefieldRect) {
					var zoneLeft = battlefieldRect.left - playmatRect.left;
					var zoneTop = battlefieldRect.top - playmatRect.top;
					card.left = Math.round(zoneLeft + (battlefieldRect.width - CARD_WIDTH) / 2);
					card.top = Math.round(zoneTop + (battlefieldRect.height - CARD_HEIGHT) / 2);
				}
			});
		} else if (zone === 'graveyard') {
			c.data.graveyard.push(card);
			$timeout(function() {
				snapToGraveyard(card);
			});
		} else if (zone === 'exile') {
			c.data.exile.push(card);
			$timeout(function() {
				snapToExile(card);
			});
		} else if (zone === 'library') {
			c.data.library.unshift(card); // Add to top of library
		}
		// Update cards array (do NOT include library)
		c.cards = (c.data.showCommandZone ? c.data.commanders : [])
			.concat(c.data.hand)
			.concat(c.data.battlefield)
			.concat(c.data.graveyard)
			.concat(c.data.exile)
			.concat(c.data.showSideboardZone ? c.data.sideboard : []);
		c.hideModalCardMenu();
		c.hideZoneModal();
		$timeout(function() {
			c.renderCards();
		});
	};
	// Route back to the deck page
	c.goToDeck = function() {
		if (c.data.deck_sys_id) {
			$window.location.href = "/mtg?id=deck_view&deck_id=" + c.data.deck_id;
		}
	};
	// Expose removeFromZone for modal menu logic
	c.removeFromZone = removeFromZone;
};]]></client_script>
        <controller_as>c</controller_as>
        <css>/* Container wrapper */&#13;
.playtester-basic {&#13;
  width: 100%;&#13;
  height: 100vh;&#13;
}&#13;
&#13;
/* Playmat grid layout */&#13;
.playmat {&#13;
  display: grid;&#13;
  grid-template-columns: 200px 1fr 200px; /* wider side columns */&#13;
  grid-template-rows: 1fr;&#13;
  gap: 0;&#13;
  width: 100%;&#13;
  height: 88vh;&#13;
  background: $brand-primary;&#13;
  border-radius: 1%;&#13;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
  user-select: none;&#13;
  margin-top: 1rem;&#13;
}&#13;
&#13;
/* Left &amp; Right Columns */&#13;
.left-column, .right-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: flex-start;&#13;
  align-items: center;&#13;
  gap: 1rem;&#13;
  padding: 1rem 0;&#13;
  margin-left: 1rem;&#13;
  margin-right:1rem;&#13;
}&#13;
&#13;
/* Center column zones */&#13;
.center-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: space-between;&#13;
  padding: 1rem;&#13;
}&#13;
&#13;
/* Zones shared style */&#13;
.zone, .sideboard-zone {&#13;
  border: 1px dashed $brand-secondary;&#13;
  color: $brand-secondary;&#13;
  text-align: center;&#13;
  font-weight: bold;&#13;
  padding: 4px;&#13;
  box-sizing: border-box;&#13;
}&#13;
&#13;
/* Zone sizes for new card size */&#13;
.library, .graveyard, .exile, .command-zone, .sideboard-zone {&#13;
  width: 19rem;&#13;
  height: 264px;&#13;
  position: relative;&#13;
}&#13;
&#13;
/* Styling to put zone above cards within the zone */&#13;
.graveyard, .exile, .sideboard-zone, .command-zone {&#13;
  z-index: 20;&#13;
}&#13;
&#13;
/* Battlefield */&#13;
.battlefield {&#13;
  flex-grow: 1;&#13;
  margin-bottom: 20px;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
}&#13;
&#13;
/* Hand */&#13;
.hand {&#13;
  height: 284px;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
}&#13;
&#13;
/* Command zone styling */&#13;
.command-zone {&#13;
  border: 1px solid #fff;&#13;
  border-radius: 4px;&#13;
  background: transparent;&#13;
}&#13;
&#13;
/* Sideboard zone styling */&#13;
.sideboard-zone {&#13;
  background: transparent;&#13;
  border: 1px solid #fff;&#13;
  border-radius: 4px;&#13;
  margin-top: 10px;&#13;
  display: flex;&#13;
  align-items: center;&#13;
  justify-content: center;&#13;
  cursor: pointer;&#13;
}&#13;
&#13;
/* Health display */&#13;
.health-display {&#13;
  color: #eee;&#13;
  font-size: 18px;&#13;
  text-align: center;&#13;
  user-select: none;&#13;
}&#13;
&#13;
/* Health button styling */&#13;
.health-display button {&#13;
  margin: 5px;&#13;
  padding: 6px 12px;&#13;
  font-size: 16px;&#13;
  background: #444;&#13;
  border: none;&#13;
  border-radius: 4px;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
}&#13;
&#13;
.health-display button:hover {&#13;
  background: #666;&#13;
}&#13;
&#13;
/* Draggable cards */&#13;
.draggable-card {&#13;
  position: absolute;&#13;
  width: 19rem;&#13;
  cursor: grab;&#13;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);&#13;
  border-radius: 6px;&#13;
  user-select: none;&#13;
  z-index: 10;&#13;
  padding:0px; &#13;
  border:0px;&#13;
  border-radius:5%;&#13;
  transform-origin: center center;&#13;
  transition: transform 0.2s ease, z-index 0.2s ease, box-shadow 0.2s ease, left 0.3s ease, top 0.3s ease;&#13;
}&#13;
&#13;
.draggable-card img {&#13;
  width: 100%;&#13;
  height: 264px;&#13;
  border-radius:5%&#13;
}&#13;
&#13;
.draggable-card.rotated {&#13;
  transform: rotate(90deg);&#13;
}&#13;
&#13;
/* Hand card hover effects */&#13;
.draggable-card[data-zone="hand"]:hover {&#13;
  z-index: 21 !important;&#13;
  transform: scale(1.3) !important;&#13;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6) !important;&#13;
}&#13;
&#13;
.draggable-card[data-zone="hand"].rotated:hover {&#13;
  z-index: 21 !important;&#13;
  transform: rotate(90deg) scale(1.3) !important;&#13;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6) !important;&#13;
}&#13;
&#13;
/* Library card back */&#13;
.zone.library {&#13;
  position: relative;&#13;
  width: 19rem;&#13;
  height: 264px;&#13;
}&#13;
&#13;
.library-card-back {&#13;
  position: absolute;&#13;
  top: 50%;&#13;
  left: 50%;&#13;
  width: 19rem;&#13;
  height: 264px;&#13;
  transform: translate(-50%, -50%);&#13;
  cursor: pointer;&#13;
  border-radius: 5%;&#13;
}&#13;
&#13;
/* Zone Modal Styles */&#13;
.zone-modal {&#13;
  position: fixed;&#13;
  top: 0;&#13;
  left: 0;&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  background: $brand-primary;&#13;
  z-index: 100;&#13;
  display: flex;&#13;
  justify-content: center;&#13;
  align-items: center;&#13;
}&#13;
&#13;
.modal-content {&#13;
  background: $brand-primary !important;&#13;
  border: 2px solid $brand-secondary;&#13;
  border-radius: 8px;&#13;
  max-width: 90%;&#13;
  max-height: 90%;&#13;
  width: 800px;&#13;
  height: 600px;&#13;
  flex-direction: column;&#13;
  overflow: scroll;&#13;
}&#13;
&#13;
.modal-header {&#13;
  display: flex;&#13;
  justify-content: space-between;&#13;
  align-items: center;&#13;
  padding: 15px 20px;&#13;
  border-bottom: 1px solid #444;&#13;
  background: $brand-secondary;&#13;
  border-radius: 6px 6px 0 0;&#13;
}&#13;
&#13;
.modal-header h3 {&#13;
  color: $black;&#13;
  margin: 0;&#13;
  font-size: 18px;&#13;
  font-weight: bold;&#13;
}&#13;
&#13;
.close-button {&#13;
  background: none;&#13;
  border: none;&#13;
  color: $black;&#13;
  font-size: 24px;&#13;
  cursor: pointer;&#13;
  padding: 0;&#13;
  width: 30px;&#13;
  height: 30px;&#13;
  display: flex;&#13;
  align-items: center;&#13;
  justify-content: center;&#13;
  border-radius: 4px;&#13;
}&#13;
&#13;
.modal-body {&#13;
  flex: 1;&#13;
  padding: 20px;&#13;
  background-color: $brand-primary;&#13;
}&#13;
&#13;
.zone-cards-grid {&#13;
  display: grid;&#13;
  grid-template-columns: repeat(auto-fill, minmax(181px, 1fr));&#13;
  gap: 15px;&#13;
  position: relative;&#13;
  justify-items: center;&#13;
}&#13;
&#13;
.modal-card {&#13;
  width: 19rem;&#13;
  height: 264px;&#13;
  cursor: grab;&#13;
  border-radius: 6px;&#13;
  user-select: none;&#13;
  transition: transform 0.2s ease, box-shadow 0.2s ease;&#13;
  position: relative;&#13;
}&#13;
&#13;
.modal-card:hover {&#13;
  transform: scale(1.05);&#13;
  box-shadow: 0 6px 20px rgba(0,0,0,0.6);&#13;
  z-index: 10;&#13;
}&#13;
&#13;
.modal-card img {&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  border-radius: 6px;&#13;
  object-fit: cover;&#13;
}&#13;
&#13;
.modal-card.rotated {&#13;
  transform: rotate(90deg);&#13;
}&#13;
&#13;
.modal-card.rotated:hover {&#13;
  transform: rotate(90deg) scale(1.05);&#13;
}&#13;
&#13;
/* Library context menu styles */&#13;
.library-context-menu {&#13;
  position: fixed;&#13;
  z-index: 200;&#13;
  background: #232323;&#13;
  color: #fff;&#13;
  border: 1px solid #444;&#13;
  border-radius: 6px;&#13;
  min-width: 160px;&#13;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);&#13;
  padding: 0;&#13;
  margin: 0;&#13;
  list-style: none;&#13;
  font-size: 16px;&#13;
}&#13;
&#13;
.library-context-menu li {&#13;
  padding: 10px 18px;&#13;
  cursor: pointer;&#13;
  border-bottom: 1px solid #333;&#13;
  transition: background 0.15s;&#13;
}&#13;
&#13;
.library-context-menu li:last-child {&#13;
  border-bottom: none;&#13;
}&#13;
&#13;
.library-context-menu li:hover {&#13;
  background: #444;&#13;
}&#13;
&#13;
/* Modal card context menu styles */&#13;
.modal-card-context-menu {&#13;
  position: fixed;&#13;
  z-index: 200;&#13;
  background: #232323;&#13;
  color: #fff;&#13;
  border: 1px solid #444;&#13;
  border-radius: 6px;&#13;
  min-width: 140px;&#13;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);&#13;
  padding: 0;&#13;
  margin: 0;&#13;
  list-style: none;&#13;
  font-size: 15px;&#13;
}&#13;
&#13;
.modal-card-context-menu li {&#13;
  padding: 8px 16px;&#13;
  cursor: pointer;&#13;
  border-bottom: 1px solid #333;&#13;
  transition: background 0.15s;&#13;
}&#13;
&#13;
.modal-card-context-menu li:last-child {&#13;
  border-bottom: none;&#13;
}&#13;
&#13;
.modal-card-context-menu li:hover {&#13;
  background: $brand-primary;&#13;
}&#13;
&#13;
.draggable-card:focus {&#13;
  outline: 5px solid #ffd700;&#13;
  outline-offset: 2px;&#13;
}&#13;
&#13;
.counters {&#13;
 color:white;&#13;
  font-size: 2rem;&#13;
  text-align: center;&#13;
}&#13;
&#13;
.view-deck {&#13;
  background-color: $brand-secondary;&#13;
  color: $black;&#13;
  border: none;&#13;
  padding: 6px 12px;&#13;
  border-radius: 4px;&#13;
  cursor: pointer;&#13;
  font-size: 13px;&#13;
  font-weight: bold; &#13;
}&#13;
&#13;
.view-deck:hover {&#13;
  background-color: #e27c00;&#13;
}&#13;
&#13;
.hover-buttons {&#13;
  position: absolute;&#13;
  top: 4.5rem;&#13;
  right: 0px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  z-index: 30;&#13;
}&#13;
&#13;
.hover-btn {&#13;
  background-color: rgba(249,250,251,.05);&#13;
  border: 2px solid hsla(0,0%,100%,.5);&#13;
  width: 5rem;&#13;
  height: 5rem;&#13;
  font-size: 3.5rem;&#13;
  font-weight: bolder;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
  transition: background-color .2s ease-in-out;&#13;
  padding: 0;&#13;
  line-height: 1;&#13;
  text-align: center;&#13;
}&#13;
&#13;
.hover-btn.flip {&#13;
  position: absolute;&#13;
  left: -20rem;&#13;
}&#13;
&#13;
&#13;
.hover-btn.card-modal {&#13;
  background-color: rgba(249,250,251,.05);&#13;
  border: 2px solid hsla(0,0%,100%,.5);&#13;
  font-size: 3.5rem;&#13;
  font-weight: bolder;&#13;
  width: 4rem;&#13;
  height: 4rem;&#13;
  z-index: 30;&#13;
}&#13;
&#13;
.hover-btn:hover {&#13;
  background-color: rgba(249,250,251,.3);&#13;
}</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>mtg_playtest</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck Playtest</name>
        <option_schema>[{"name":"deck_sys_id","section":"other","default_value":"d81646edc38326100efafbfdd401318f","label":"Deck Sys ID","type":"string"}]</option_schema>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
    // Check for deck_id in URL parameter, then options, then input
    var urlDeckId = $sp && $sp.getParameter ? $sp.getParameter("deck_id") : null;
    var deckId = urlDeckId || options.deck_sys_id || input.deck_sys_id;

	var magicUtils = new x_759224_magic_c_0.magic_utils();

	data.turn = 0;
    data.deck_id = deckId;
    // Default fallback
    data.playerHealth = 20;
    var showCommandZone = false;
    var showSideboardZone = false;
    // Load deck record
    var deckGR = new GlideRecord('x_759224_magic_c_0_mtg_deck');
    if (deckGR.get(deckId)) {
        var formatSysId = deckGR.getValue('format');

        // Load related format record
        var formatGR = new GlideRecord('x_759224_magic_c_0_deck_formats');
        if (formatGR.get(formatSysId)) {
            var hp = parseInt(formatGR.getValue('starting_hp'), 10);
            if (!isNaN(hp)) {
                data.playerHealth = hp;
            }
            // Check if commander is required for this format
            showCommandZone = formatGR.getValue('commander_required') == '1';
            // Check if sideboard is used for this format
            showSideboardZone = formatGR.getValue('uses_sideboard') == '1';
        }
    }

    data.commanders = [];
    data.hand = [];
    data.library = [];
    data.showCommandZone = showCommandZone;
    data.showSideboardZone = showSideboardZone;
    data.sideboard = [];

    if (!deckId) {
        data.error = "No deck_sys_id provided.";
        return;
    }

    var utils = new x_759224_magic_c_0.magic_utils();

    var deckCardGR = new GlideRecord('x_759224_magic_c_0_deck_card');
    deckCardGR.addQuery('deck', deckId);
    deckCardGR.query();

    var commanders = [];
    var nonCommanders = [];

    // Add sideboard cards
    var sideboard = [];
    // Loop through each of the deck card records
    while (deckCardGR.next()) {
        // Get quantity so we add
        var quantity = parseInt(deckCardGR.getValue('quantity'), 10) || 1;
        var isCommander = deckCardGR.is_commander.toString() === 'true';
        var isSideboard = deckCardGR.is_sideboard.toString() === 'true';
        var isMaybeboard = deckCardGR.is_maybeboard.toString() === 'true';
        // If the card exists and is not sideboard nor maybeboard
        var cardGR = new GlideRecord('x_759224_magic_c_0_mtg_cards');
        if (cardGR.get(deckCardGR.getValue('card')) && !isMaybeboard) {
            var cardData = magicUtils.getCardData(deckCardGR.getValue('card'));
			cardData.is_commander = isCommander;
			cardData.notes = deckCardGR.getValue('notes');
			gs.info(JSON.stringify(cardData));
			// {
            //     sys_id: cardGR.getUniqueValue(),
            //     name: cardGR.getValue('name'),
            //     front_image: utils.getImgSrc(cardGR.getValue('front_image')),
            //     back_image: utils.getImgSrc(cardGR.getValue('back_image')),
            //     is_commander: isCommander,
            //     notes: deckCardGR.getValue('notes'),
                
            // };
            if (isSideboard) {
                for (var i = 0; i < quantity; i++) {
                    sideboard.push(Object.assign({}, cardData));
                }
            } else if (!isSideboard) {
                var targetArray = cardData.is_commander ? commanders : nonCommanders;
                for (var i = 0; i < quantity; i++) {
                    targetArray.push(Object.assign({}, cardData));
                }
            }
        }
    }
    data.sideboard = sideboard;

    // Shuffle non-commander cards
    function shuffle(array) {
        var currentIndex = array.length,
            randomIndex;

        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;

            var temp = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temp;
        }

        return array;
    }

    shuffle(nonCommanders);

    data.hand = nonCommanders.slice(0, 7);
    data.library = nonCommanders.slice(7);
    data.commanders = commanders;
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>greg</sys_created_by>
        <sys_created_on>2023-10-05 04:26:39</sys_created_on>
        <sys_id>b4bd4bbb972d3d1078cb33121153afcd</sys_id>
        <sys_mod_count>241</sys_mod_count>
        <sys_name>MTG Deck Playtest</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_b4bd4bbb972d3d1078cb33121153afcd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-04 16:30:22</sys_updated_on>
        <template><![CDATA[<div class="playtester-basic">
  <div class="playmat">
    <!-- Left Column -->
    <div class="left-column">
      <div class="zone library" ng-click="c.showZoneModal('library')" ng-right-click="c.showLibraryContextMenu($event)">
        <img ng-if="c.data.library.length > 0"
             src="https://backs.scryfall.io/normal/2/2/222b7a3b-2321-4d4c-af19-19338b134971.jpg?1677416389"
             alt="Library Card Back"
             class="library-card-back" />
      </div>
      <div class="zone graveyard" ng-click="c.showZoneModal('graveyard')">Graveyard</div>
      <div class="zone exile" ng-click="c.showZoneModal('exile')">Exile</div>
      <div class="counters">
        <div class="hand-counter">Cards: {{c.data.hand.length}}</div>
        <div class="turn-counter"> Turn: {{c.data.turn}} </div>
      </div>
      <button class="view-deck" ng-click="c.goToDeck()">View Deck</button>
    </div>

    <!-- Center Column -->
    <div class="center-column">
      <div class="zone battlefield">Battlefield</div>
      <div class="zone hand">Hand</div>
    </div>

    <!-- Right Column -->
    <div class="right-column">
      <div class="zone command-zone" ng-click="c.showZoneModal('command')" ng-if="c.data.showCommandZone">Command Zone</div>
      <div class="zone sideboard-zone" ng-click="c.showZoneModal('sideboard')" ng-if="c.data.showSideboardZone">Sideboard</div>
      <div class="health-display">
        <div class="player-health">Health: {{c.playerHealth}}</div>
        <button ng-click="c.modifyHealth(-1)">-1</button>
        <button ng-click="c.modifyHealth(1)">+1</button>
      </div>
    </div>

    <!-- Draggable Cards -->
    <div class="draggable-card"
            ng-repeat="card in c.cards"
         	role="button"
            ng-class="{'rotated': card.isTapped, 'hand-card': c.getCardZone(card) === 'hand'}"
            ng-attr-data-zone="{{c.getCardZone(card)}}"
            ng-style="{'left': card.left + 'px', 'top': card.top + 'px'}"
            tabindex="0"
            ng-click="c.showCardContextMenu($event, card)">
      <img ng-src="{{card.face_one.image}}" alt="{{card.name}}">
      <div class="hover-buttons">
        <button class="hover-btn card-modal">⚙</button>
      </div>
    </div>
  </div>

  <!-- Zone Modal -->
  <div class="zone-modal" ng-if="c.showModal" ng-click="c.hideZoneModal()">
    <div class="modal-content" ng-click="$event.stopPropagation()">
      <div class="modal-header">
        <h3>{{c.modalTitle}}</h3>
        <button class="close-button" ng-click="c.hideZoneModal()">×</button>
      </div>
      <div class="modal-body">
        <div class="zone-cards-grid">
          <div class="modal-card"
               ng-repeat="card in c.modalCards"
               ng-class="{'rotated': card.isTapped}"
               ng-click="c.showModalCardMenu($event, card)">
            <img ng-src="{{card.face_one.image}}" alt="{{card.name}}">
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom context menu for library -->
  <ul class="library-context-menu" ng-show="c.libraryMenuVisible" ng-style="{'top': c.libraryMenuY + 'px', 'left': c.libraryMenuX + 'px'}">
    <li ng-click="c.drawCard(); c.hideLibraryContextMenu()">Draw</li>
    <li ng-click="c.shuffleLibrary(); c.hideLibraryContextMenu()">Shuffle</li>
    <li ng-click="c.showZoneModal('library'); c.hideLibraryContextMenu()">View Library</li>
    <li ng-click="c.hideLibraryContextMenu()">Cancel</li>
  </ul>

  <!-- Modal card context menu -->
  <ul class="modal-card-context-menu" ng-show="c.modalCardMenuVisible" ng-style="{'top': c.modalCardMenuY + 'px', 'left': c.modalCardMenuX + 'px'}">
    <li ng-repeat="zone in c.getAvailableZonesForModalCard()" ng-click="c.moveModalCardToZone(zone)">{{zone | uppercase}}</li>
    <li ng-click="c.hideModalCardMenu()">Cancel</li>
  </ul>

</div>]]></template>
    </sp_widget>
</record_update>
