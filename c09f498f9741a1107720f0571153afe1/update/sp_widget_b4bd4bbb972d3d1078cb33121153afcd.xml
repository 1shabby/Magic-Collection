<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $element, $timeout) {
    var c = this;

    c.playerHealth = c.data.playerHealth || 20;
    c.cards = []; // All draggable cards (commanders + hand + any new cards)

    var draggingCard = null;
    var offsetX = 0,
        offsetY = 0;

    // Card metrics
    var CARD_WIDTH = 181;
    var CARD_HEIGHT = 264;
    var DEFAULT_GAP_X = 10;
    var MIN_STEP_X = 24; // minimal overlap step to handle overflow

    c.modifyHealth = function(amount) {
        $scope.$applyAsync(function() {
            c.playerHealth = Math.max(0, c.playerHealth + amount);
        });
    };

    // Helper: DOM rects for zones
    function getZoneRects() {
        var playmatEl = $element[0];
        return {
            playmat: playmatEl.getBoundingClientRect(),
            hand: playmatEl.querySelector('.hand').getBoundingClientRect(),
            battlefield: playmatEl.querySelector('.battlefield').getBoundingClientRect(),
            command: playmatEl.querySelector('.command-zone').getBoundingClientRect(),
            graveyard: playmatEl.querySelector('.graveyard').getBoundingClientRect(),
            exile: playmatEl.querySelector('.exile').getBoundingClientRect()
        };
    }

    function pointInRect(x, y, rect) {
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    }

    function removeFromHand(card) {
        var idx = c.data.hand.indexOf(card);
        if (idx !== -1) c.data.hand.splice(idx, 1);
    }

    function ensureInHand(card, atStart) {
        var idx = c.data.hand.indexOf(card);
        if (idx === -1) {
            if (atStart) c.data.hand.unshift(card);
            else c.data.hand.push(card);
        }
    }

    // Layout all cards that are in the hand zone (by membership), left-to-right.
    c.layoutHand = function() {
        var playmatEl = $element[0];
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var handRect = rects.hand;

        var leftStart = handRect.left - playmatRect.left + 10; // small inner padding
        var topPos = handRect.bottom - playmatRect.top - CARD_HEIGHT - 10;
        var availableWidth = handRect.width - 20; // padding on both sides

        // Get all cards that are in hand zone
        var handCards = c.data.hand.filter(function(card) {
            return card.currentZone === 'hand';
        });

        if (handCards.length === 0) return;

        var step;

        // Calculate spacing based on number of cards
        if (handCards.length === 1) {
            // Single card - center it
            step = 0;
            leftStart = leftStart + (availableWidth - CARD_WIDTH) / 2;
        } else if (handCards.length * (CARD_WIDTH + DEFAULT_GAP_X) <= availableWidth) {
            // Enough space for generous spacing
            step = CARD_WIDTH + DEFAULT_GAP_X;
        } else {
            // Need to compress - calculate overlap
            var totalCardsWidth = handCards.length * CARD_WIDTH;
            var neededOverlap = (totalCardsWidth - availableWidth) / Math.max(1, handCards.length - 1);

            // For extreme cases (30+ cards), allow heavy overlap but ensure minimum visibility
            var minVisibleWidth = Math.max(20, CARD_WIDTH * 0.1); // At least 10% of card width visible
            var maxOverlap = CARD_WIDTH - minVisibleWidth;

            var overlapAmount = Math.min(maxOverlap, neededOverlap);
            step = CARD_WIDTH - overlapAmount;
        }

        // Position ALL hand cards in order to ensure proper fanning
        handCards.forEach(function(card, index) {
            card.left = Math.round(leftStart + index * step);
            card.top = Math.round(topPos);
        });
    };

    // Draw from the top of the library; new card goes to LEFTMOST of the hand.
    c.drawCard = function() {
        if (c.data.library.length === 0) return;

        var drawnCard = c.data.library.shift();

        // Establish default zone for drawn card
        drawnCard.currentZone = 'hand';

        // Reset position - will be assigned by layoutHand
        drawnCard.left = undefined;
        drawnCard.top = undefined;

        // New draws go to the end of the hand (next to existing cards)
        ensureInHand(drawnCard, false);

        // Keep it on top visually
        c.cards.push(drawnCard);

        c.renderCards();
    };

    c.renderCards = function() {
        var playmatEl = $element[0];
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var commandRect = rects.command;
        var handRect = rects.hand;

        // Initialize zone and position if needed
        c.cards.forEach(function(card) {
            if (card.currentZone === undefined) {
                if (card.is_commander) card.currentZone = 'command';
                else card.currentZone = 'hand';
            }

            // Commanders: center in command zone if no position yet
            if (card.is_commander && (card.left === undefined || card.top === undefined)) {
                var zoneLeft = commandRect.left - playmatRect.left;
                var zoneTop = commandRect.top - playmatRect.top;
                card.left = Math.round(zoneLeft + (commandRect.width - CARD_WIDTH) / 2);
                card.top = Math.round(zoneTop + (commandRect.height - CARD_HEIGHT) / 2);
            }
            // Non-commander, non-hand: if no position, leave as-is (user will drag)
        });

        // Always layout hand if there are cards in hand to ensure proper fanning
        var handCards = c.data.hand.filter(function(card) {
            return card.currentZone === 'hand';
        });

        if (handCards.length > 0) {
            c.layoutHand();
        }

        // Apply to DOM and wire DnD
        $timeout(function() {
            var cardsEls = playmatEl.querySelectorAll('.draggable-card');

            cardsEls.forEach(function(cardEl, i) {
                cardEl.style.position = 'absolute';

                var card = c.cards[i];
                if (!card) return;

                cardEl.style.left = card.left + 'px';
                cardEl.style.top = card.top + 'px';

                if (card.isTapped) cardEl.classList.add('rotated');
                else cardEl.classList.remove('rotated');

                // Clean old handlers
                cardEl.onmousedown = null;
                cardEl.onmouseup = null;
                cardEl.ondblclick = null;
                document.onmousemove = null;

                cardEl.addEventListener('mousedown', function(e) {
                    //console.log(card);
                    draggingCard = card;
                    //console.log(draggingCard.currentZone);
                    var currentRects = getZoneRects(); // refresh per interaction
                    var localPlaymatRect = currentRects.playmat;

                    offsetX = e.clientX - card.left;
                    offsetY = e.clientY - card.top;
                    cardEl.style.cursor = 'grabbing';
                    cardEl.style.transition = 'none';
                    e.preventDefault();

                    document.onmousemove = function(e2) {
                        if (!draggingCard) return;
                        draggingCard.left = e2.clientX - offsetX;
                        draggingCard.top = e2.clientY - offsetY;

                        cardEl.style.left = draggingCard.left + 'px';
                        cardEl.style.top = draggingCard.top + 'px';
                    };

                    document.onmouseup = function() {
                        if (!draggingCard) return;

						//var draggingCard = card;

                        // Determine drop zone by card center in page coords
                        var centerX = draggingCard.left + CARD_WIDTH / 2 + localPlaymatRect.left;
                        var centerY = draggingCard.top + CARD_HEIGHT / 2 + localPlaymatRect.top;

                        var dropZone = null;
                        var rectsNow = getZoneRects();
                        if (pointInRect(centerX, centerY, rectsNow.hand)) dropZone = 'hand';
                        else if (pointInRect(centerX, centerY, rectsNow.battlefield)) dropZone = 'battlefield';
                        else if (pointInRect(centerX, centerY, rectsNow.command)) dropZone = 'command';
                        else if (pointInRect(centerX, centerY, rectsNow.graveyard)) dropZone = 'graveyard';
                        else if (pointInRect(centerX, centerY, rectsNow.exile)) dropZone = 'exile';

                        console.log(dropZone);

                        $scope.$applyAsync(function() {
                            if (dropZone === 'hand') {
                                console.log("HELLO WORLD");
                                draggingCard.currentZone = 'hand';
                                ensureInHand(draggingCard, false); // append if user drops into hand
                                // Reset position so layoutHand can position it properly
                                draggingCard.left = undefined;
                                draggingCard.top = undefined;
                                c.layoutHand();
                            } else {
                                if (draggingCard.currentZone === 'hand') {
                                    removeFromHand(draggingCard);
                                }
                                draggingCard.currentZone = dropZone || 'free';
                                // Keep position where user dropped it
                            }
                        });

                        cardEl.style.cursor = 'grab';
                        cardEl.style.transition = '';
                        //draggingCard = null;
                        document.onmousemove = null;
                        document.onmouseup = null;
                    };
                });

                cardEl.addEventListener('dblclick', function() {
                    $scope.$applyAsync(function() {
                        card.isTapped = !card.isTapped;
                    });
                });
            });
        });
    };

    c.$onInit = function() {
        // Combine commanders and hand into cards array for rendering & dragging
        c.cards = (c.data.commanders || []).concat(c.data.hand || []);

        // Initialize zones for existing cards
        (c.data.commanders || []).forEach(function(card) {
            card.currentZone = 'command';
        });
        (c.data.hand || []).forEach(function(card) {
            card.currentZone = 'hand';
        });

        $timeout(function() {
            c.renderCards();
        });
    };
};]]></client_script>
        <controller_as>c</controller_as>
        <css>/* Container wrapper */&#13;
.playtester-basic {&#13;
  width: 100%;&#13;
  height: 1000px; /* Increased for larger cards */&#13;
}&#13;
&#13;
/* Playmat grid layout */&#13;
.playmat {&#13;
  display: grid;&#13;
  grid-template-columns: 200px 1fr 200px; /* wider side columns */&#13;
  grid-template-rows: 1fr;&#13;
  gap: 0;&#13;
  width: 100%;&#13;
  height: 88vh;&#13;
  background: black;&#13;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
  user-select: none;&#13;
}&#13;
&#13;
/* Left &amp; Right Columns */&#13;
.left-column, .right-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: flex-start;&#13;
  align-items: center;&#13;
  gap: 20px;&#13;
  padding: 20px 0;&#13;
}&#13;
&#13;
/* Center column zones */&#13;
.center-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: space-between;&#13;
  padding: 20px;&#13;
}&#13;
&#13;
/* Zones shared style */&#13;
.zone {&#13;
  border: 1px dashed white;&#13;
  color: white;&#13;
  text-align: center;&#13;
  font-weight: bold;&#13;
  padding: 4px;&#13;
  box-sizing: border-box;&#13;
}&#13;
&#13;
/* Zone sizes for new card size */&#13;
.library, .graveyard, .exile, .command-zone {&#13;
  width: 181px;&#13;
  height: 264px;&#13;
}&#13;
&#13;
/* Battlefield */&#13;
.battlefield {&#13;
  flex-grow: 1;&#13;
  margin-bottom: 20px;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
}&#13;
&#13;
/* Hand */&#13;
.hand {&#13;
  height: 284px;&#13;
  position: relative; /* helps when computing rects and improves UX */&#13;
  overflow: hidden;   /* visual containment; cards are absolutely positioned on playmat */&#13;
}&#13;
&#13;
/* Command zone styling */&#13;
.command-zone {&#13;
  background: #b03030;&#13;
  border: 1px solid #fff;&#13;
  border-radius: 4px;&#13;
}&#13;
&#13;
/* Health display */&#13;
.health-display {&#13;
  color: #eee;&#13;
  font-size: 18px;&#13;
  text-align: center;&#13;
  user-select: none;&#13;
}&#13;
&#13;
.health-display button {&#13;
  margin: 5px;&#13;
  padding: 6px 12px;&#13;
  font-size: 16px;&#13;
  background: #444;&#13;
  border: none;&#13;
  border-radius: 4px;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
}&#13;
&#13;
.health-display button:hover {&#13;
  background: #666;&#13;
}&#13;
&#13;
/* Draggable cards (scaled up again) */&#13;
.draggable-card {&#13;
  position: absolute;&#13;
  width: 181px;&#13;
  cursor: grab;&#13;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);&#13;
  border-radius: 6px;&#13;
  user-select: none;&#13;
  z-index: 1000;&#13;
  transform-origin: center center;&#13;
  transition: transform 0.2s ease, z-index 0.2s ease, box-shadow 0.2s ease;&#13;
}&#13;
&#13;
.draggable-card img {&#13;
  width: 100%;&#13;
  height: 264px;&#13;
  border-radius: 6px;&#13;
}&#13;
&#13;
.draggable-card.rotated {&#13;
  transform: rotate(90deg);&#13;
}&#13;
&#13;
/* Hand card hover effects */&#13;
.draggable-card.hand-card:hover,&#13;
.draggable-card[data-zone="hand"]:hover {&#13;
  z-index: 2000 !important;&#13;
  transform: scale(1.3) !important;&#13;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6) !important;&#13;
}&#13;
&#13;
/* Handle rotated cards in hand */&#13;
.draggable-card.hand-card.rotated:hover,&#13;
.draggable-card[data-zone="hand"].rotated:hover {&#13;
  z-index: 2000 !important;&#13;
  transform: rotate(90deg) scale(1.3) !important;&#13;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6) !important;&#13;
}&#13;
&#13;
/* Library card back (match new size) */&#13;
.zone.library {&#13;
  position: relative;&#13;
  width: 181px;&#13;
  height: 264px;&#13;
}&#13;
&#13;
.library-card-back {&#13;
  position: absolute;&#13;
  top: 50%;&#13;
  left: 50%;&#13;
  width: 181px;&#13;
  height: 264px;&#13;
  transform: translate(-50%, -50%);&#13;
  cursor: pointer;&#13;
  border-radius: 0.6%;&#13;
}&#13;
&#13;
img {&#13;
 border-radius: 0.6rem; &#13;
}&#13;
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>mtg_drag</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck Playtest</name>
        <option_schema>[{"name":"deck_sys_id","section":"other","default_value":"d81646edc38326100efafbfdd401318f","label":"Deck Sys ID","type":"string"}]</option_schema>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
    var deckId = options.deck_sys_id || input.deck_sys_id;

    // Default fallback
    data.playerHealth = 20;

    // Load deck record
    var deckGR = new GlideRecord('x_759224_magic_c_0_mtg_deck');
    if (deckGR.get(deckId)) {
        var formatSysId = deckGR.getValue('format');

        // Load related format record
        var formatGR = new GlideRecord('x_759224_magic_c_0_deck_formats');
        if (formatGR.get(formatSysId)) {
            var hp = parseInt(formatGR.getValue('starting_hp'), 10);
            if (!isNaN(hp)) {
                data.playerHealth = hp;
            }
        }
    }

    data.commanders = [];
    data.hand = [];
    data.library = [];

    if (!deckId) {
        data.error = "No deck_sys_id provided.";
        return;
    }

    var utils = new x_759224_magic_c_0.magic_utils();

    var deckCardGR = new GlideRecord('x_759224_magic_c_0_deck_card');
    deckCardGR.addQuery('deck', deckId);
    deckCardGR.query();

    var commanders = [];
    var nonCommanders = [];

    // Loop through each of the deck card records
    while (deckCardGR.next()) {
        // Get quantity so we add
        var quantity = parseInt(deckCardGR.getValue('quantity'), 10) || 1;
        var isCommander = deckCardGR.is_commander.toString() === 'true';
        var isSideboard = deckCardGR.is_sideboard.toString() === 'true';
        var isMaybeboard = deckCardGR.is_maybeboard.toString() === 'true';
        // If the card exists and is not sideboard nor maybeboard
        var cardGR = new GlideRecord('x_759224_magic_c_0_mtg_cards');
        if (cardGR.get(deckCardGR.getValue('card')) && !isSideboard && !isMaybeboard) {
            var cardData = {
                sys_id: cardGR.getUniqueValue(),
                name: cardGR.getValue('name'),
                front_image: utils.getImgSrc(cardGR.getValue('front_image')),
                back_image: utils.getImgSrc(cardGR.getValue('back_image')),
                is_commander: isCommander,
                notes: deckCardGR.getValue('notes')

            };

            var targetArray = cardData.is_commander ? commanders : nonCommanders;
            for (var i = 0; i < quantity; i++) {
                targetArray.push(Object.assign({}, cardData));
            }
        }
    }

    // Shuffle non-commander cards
    function shuffle(array) {
        var currentIndex = array.length,
            randomIndex;

        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;

            var temp = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temp;
        }

        return array;
    }

    shuffle(nonCommanders);

    data.hand = nonCommanders.slice(0, 7);
    data.library = nonCommanders.slice(7);
    data.commanders = commanders;
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>greg</sys_created_by>
        <sys_created_on>2023-10-05 04:26:39</sys_created_on>
        <sys_id>b4bd4bbb972d3d1078cb33121153afcd</sys_id>
        <sys_mod_count>111</sys_mod_count>
        <sys_name>MTG Deck Playtest</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_b4bd4bbb972d3d1078cb33121153afcd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-08-09 21:24:07</sys_updated_on>
        <template><![CDATA[<div class="playtester-basic">
  <div class="playmat">
    <!-- Left Column -->
    <div class="left-column">
      <div class="zone library" ng-click="c.drawCard()">
        <img ng-if="c.data.library.length > 0"
             src="https://backs.scryfall.io/normal/2/2/222b7a3b-2321-4d4c-af19-19338b134971.jpg?1677416389"
             alt="Library Card Back"
             class="library-card-back" />
      </div>
      <div class="zone graveyard">Graveyard</div>
      <div class="zone exile">Exile</div>
    </div>

    <!-- Center Column -->
    <div class="center-column">
      <div class="zone battlefield">Battlefield</div>
      <div class="zone hand">Hand</div>
    </div>

    <!-- Right Column -->
    <div class="right-column">
      <div class="zone command-zone">Command Zone</div>
      <div class="health-display">
        <div class="player-health">Health: {{c.playerHealth}}</div>
        <button ng-click="c.modifyHealth(-1)">-1</button>
        <button ng-click="c.modifyHealth(1)">+1</button>
      </div>
    </div>

    <!-- Draggable Cards -->
    <div class="draggable-card"
         ng-repeat="card in c.cards"
         ng-class="{'rotated': card.isTapped, 'hand-card': card.currentZone === 'hand'}"
         ng-attr-data-zone="{{card.currentZone}}"
         ng-style="{'left': card.left + 'px', 'top': card.top + 'px'}">
      <img ng-src="{{card.front_image}}" alt="{{card.name}}">
    </div>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
