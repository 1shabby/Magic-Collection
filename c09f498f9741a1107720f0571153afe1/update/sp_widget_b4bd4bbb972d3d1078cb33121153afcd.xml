<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $element, $timeout, $location, $window) {
    var c = this;

    c.playerHealth = c.data.playerHealth || 20;
    c.cards = []; // All draggable cards (commanders + hand + any new cards)
    let keydownListenerAdded = false;

    var draggingCard = null;
    var offsetX = 0,
        offsetY = 0;

    // Card metrics
    var CARD_WIDTH = 181;
    var CARD_HEIGHT = 264;
    var DEFAULT_GAP_X = 10;

    c.modifyHealth = function(amount) {
        $scope.$applyAsync(function() {
            c.playerHealth = Math.max(0, c.playerHealth + amount);
        });
    };

    // Helper: DOM rects for zones
    function getZoneRects() {
        var playmatEl = $element[0];
        return {
            playmat: playmatEl.getBoundingClientRect(),
            hand: playmatEl.querySelector('.hand').getBoundingClientRect(),
            battlefield: playmatEl.querySelector('.battlefield').getBoundingClientRect(),
            command: playmatEl.querySelector('.command-zone').getBoundingClientRect(),
            graveyard: playmatEl.querySelector('.graveyard').getBoundingClientRect(),
            exile: playmatEl.querySelector('.exile').getBoundingClientRect()
        };
    }

    function pointInRect(x, y, rect) {
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    }

    // Helper functions to move cards between zones
    function moveCardToZone(card, targetZone, position) {
        // Remove card from all zones first
        removeFromZone(card, 'command');
        removeFromZone(card, 'hand');
        removeFromZone(card, 'battlefield');
        removeFromZone(card, 'graveyard');
        removeFromZone(card, 'exile');

        if (targetZone != 'battlefield')
            card.isTapped = false;
        // Add card to target zone
        if (targetZone === 'command') {
            c.data.commanders.push(card);
        } else if (targetZone === 'hand') {
            c.data.hand.push(card);
        } else if (targetZone === 'battlefield') {
            if (position) {
                card.left = position.x;
                card.top = position.y;
            }
            c.data.battlefield.push(card);
        } else if (targetZone === 'graveyard') {
            c.data.graveyard.push(card);
        } else if (targetZone === 'exile') {
            c.data.exile.push(card);
        }

        // Update the c.cards array to reflect the new zone assignments
        c.cards = c.data.commanders.concat(c.data.hand).concat(c.data.battlefield).concat(c.data.graveyard).concat(c.data.exile);
    }

    function removeFromZone(card, zone) {
        var zoneArray;
        if (zone === 'command') zoneArray = c.data.commanders;
        else if (zone === 'hand') zoneArray = c.data.hand;
        else if (zone === 'battlefield') zoneArray = c.data.battlefield;
        else if (zone === 'graveyard') zoneArray = c.data.graveyard;
        else if (zone === 'exile') zoneArray = c.data.exile;

        if (zoneArray) {
            var idx = zoneArray.indexOf(card);
            if (idx !== -1) zoneArray.splice(idx, 1);
        }
    }

    function getCardZone(card) {
        if (c.data.commanders.indexOf(card) !== -1) return 'command';
        if (c.data.hand.indexOf(card) !== -1) return 'hand';
        if (c.data.battlefield.indexOf(card) !== -1) return 'battlefield';
        if (c.data.graveyard.indexOf(card) !== -1) return 'graveyard';
        if (c.data.exile.indexOf(card) !== -1) return 'exile';
        return null;
    }

    // Snap card to graveyard zone
    function snapToGraveyard(card) {
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var graveyardRect = rects.graveyard;

        // Center the card in the graveyard zone
        var zoneLeft = graveyardRect.left - playmatRect.left;
        var zoneTop = graveyardRect.top - playmatRect.top;
        card.left = Math.round(zoneLeft + (graveyardRect.width - CARD_WIDTH) / 2);
        card.top = Math.round(zoneTop + (graveyardRect.height - CARD_HEIGHT) / 2);
    }

    // Snap card to exile zone
    function snapToExile(card) {
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var exileRect = rects.exile;

        // Center the card in the exile zone
        var zoneLeft = exileRect.left - playmatRect.left;
        var zoneTop = exileRect.top - playmatRect.top;
        card.left = Math.round(zoneLeft + (exileRect.width - CARD_WIDTH) / 2);
        card.top = Math.round(zoneTop + (exileRect.height - CARD_HEIGHT) / 2);
    }

    // Snap card to command zone
    function snapToCommand(card) {
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var commandRect = rects.command;

        // Center the card in the command zone
        var zoneLeft = commandRect.left - playmatRect.left;
        var zoneTop = commandRect.top - playmatRect.top;
        card.left = Math.round(zoneLeft + (commandRect.width - CARD_WIDTH) / 2);
        card.top = Math.round(zoneTop + (commandRect.height - CARD_HEIGHT) / 2);
    }

    // Layout all cards that are in the hand zone (by membership), left-to-right.
    c.layoutHand = function() {
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var handRect = rects.hand;

        var leftStart = handRect.left - playmatRect.left + 10; // small inner padding
        var topPos = handRect.bottom - playmatRect.top - CARD_HEIGHT - 10;
        var availableWidth = handRect.width - 20; // padding on both sides

        // Get all cards that are actually in hand zone (from hand array)
        var handCards = c.data.hand;

        if (handCards.length === 0) return;

        var step;

        // Calculate spacing based on number of cards
        if (handCards.length === 1) {
            // Single card - center it
            step = 0;
            leftStart = leftStart + (availableWidth - CARD_WIDTH) / 2;
        } else if (handCards.length * (CARD_WIDTH + DEFAULT_GAP_X) <= availableWidth) {
            // Enough space for generous spacing
            step = CARD_WIDTH + DEFAULT_GAP_X;
        } else {
            // Need to compress - calculate overlap
            var totalCardsWidth = handCards.length * CARD_WIDTH;
            var neededOverlap = (totalCardsWidth - availableWidth) / Math.max(1, handCards.length - 1);

            // For extreme cases (30+ cards), allow heavy overlap but ensure minimum visibility
            var minVisibleWidth = Math.max(20, CARD_WIDTH * 0.1); // At least 10% of card width visible
            var maxOverlap = CARD_WIDTH - minVisibleWidth;

            var overlapAmount = Math.min(maxOverlap, neededOverlap);
            step = CARD_WIDTH - overlapAmount;
        }

        // Position ALL hand cards in order to ensure proper fanning
        handCards.forEach(function(card, index) {
            card.left = Math.round(leftStart + index * step);
            card.top = Math.round(topPos);
        });
    };

    // Draw from the top of the library; new card goes to LEFTMOST of the hand.
    c.drawCard = function() {
        if (c.data.library.length === 0) return;

        var drawnCard = c.data.library.shift();

        // Add card to hand
        c.data.hand.push(drawnCard);
        c.cards.push(drawnCard);

        // Layout hand to position the new card
        c.layoutHand();

        // Update DOM positions for hand cards
        $timeout(function() {
            var playmatEl = $element[0];
            var cardsEls = playmatEl.querySelectorAll('.draggable-card');

            cardsEls.forEach(function(cardEl, i) {
                var card = c.cards[i];
                if (card && c.data.hand.indexOf(card) !== -1) {
                    cardEl.style.left = card.left + 'px';
                    cardEl.style.top = card.top + 'px';
                }
            });
            // ]]>🛠<![CDATA[️ This is the fix: apply the necessary handlers to the new card
            c.renderCards();
        });
    };

    c.renderCards = function() {
        var playmatEl = $element[0];
        var rects = getZoneRects();
        var playmatRect = rects.playmat;
        var commandRect = rects.command;

        // Position commanders in command zone
        c.data.commanders.forEach(function(card) {
            if (card.left === undefined || card.top === undefined) {
                var zoneLeft = commandRect.left - playmatRect.left;
                var zoneTop = commandRect.top - playmatRect.top;
                card.left = Math.round(zoneLeft + (commandRect.width - CARD_WIDTH) / 2);
                card.top = Math.round(zoneTop + (commandRect.height - CARD_HEIGHT) / 2);
            }
        });

        // Position graveyard cards
        c.data.graveyard.forEach(function(card) {
            if (card.left === undefined || card.top === undefined) {
                snapToGraveyard(card);
            }
        });

        // Position exile cards
        c.data.exile.forEach(function(card) {
            if (card.left === undefined || card.top === undefined) {
                snapToExile(card);
            }
        });

        // Layout hand cards
        if (c.data.hand.length > 0) {
            c.layoutHand();
        }

        // Apply to DOM and wire DnD
        $timeout(function() {
            var cardsEls = playmatEl.querySelectorAll('.draggable-card');

            cardsEls.forEach(function(cardEl, i) {
                cardEl.style.position = 'absolute';

                var card = c.cards[i];
                if (!card) return;

                // Only update position if the card has a defined position and it's different from current DOM position
                // This prevents overwriting positions of cards that have been manually positioned (like on battlefield)
                if (card.left !== undefined && card.top !== undefined) {
                    var currentLeft = parseInt(cardEl.style.left) || 0;
                    var currentTop = parseInt(cardEl.style.top) || 0;

                    // Only update if the position has actually changed (with some tolerance for rounding)
                    if (Math.abs(currentLeft - card.left) > 2 || Math.abs(currentTop - card.top) > 2) {
                        cardEl.style.left = card.left + 'px';
                        cardEl.style.top = card.top + 'px';
                    }
                }

                if (card.isTapped) cardEl.classList.add('rotated');
                else cardEl.classList.remove('rotated');

                // Clean old handlers
                cardEl.onmousedown = null;
                cardEl.onmouseup = null;
                cardEl.ondblclick = null;
                document.onmousemove = null;

                cardEl.addEventListener('mousedown', function(e) {
                    draggingCard = card;
                    var currentRects = getZoneRects(); // refresh per interaction
                    var localPlaymatRect = currentRects.playmat;

                    offsetX = e.clientX - card.left;
                    offsetY = e.clientY - card.top;
                    cardEl.style.cursor = 'grabbing';
                    cardEl.style.transition = 'none';
                    e.preventDefault();

                    document.onmousemove = function(e2) {
                        if (!draggingCard) return;

                        // Safety check: ensure draggingCard is still in the cards array
                        if (c.cards.indexOf(draggingCard) === -1) {
                            draggingCard = null;
                            return;
                        }

                        draggingCard.left = e2.clientX - offsetX;
                        draggingCard.top = e2.clientY - offsetY;

                        cardEl.style.left = draggingCard.left + 'px';
                        cardEl.style.top = draggingCard.top + 'px';
                    };

                    document.onmouseup = function() {
                        if (!draggingCard) return;

                        // Safety check: ensure draggingCard is still in the cards array
                        if (c.cards.indexOf(draggingCard) === -1) {
                            draggingCard = null;
                            return;
                        }

                        // Determine drop zone by card center in page coords
                        var centerX = draggingCard.left + CARD_WIDTH / 2 + localPlaymatRect.left;
                        var centerY = draggingCard.top + CARD_HEIGHT / 2 + localPlaymatRect.top;

                        var dropZone = null;
                        var rectsNow = getZoneRects();
                        if (pointInRect(centerX, centerY, rectsNow.hand)) dropZone = 'hand';
                        else if (pointInRect(centerX, centerY, rectsNow.battlefield)) dropZone = 'battlefield';
                        else if (pointInRect(centerX, centerY, rectsNow.command)) dropZone = 'command';
                        else if (pointInRect(centerX, centerY, rectsNow.graveyard)) dropZone = 'graveyard';
                        else if (pointInRect(centerX, centerY, rectsNow.exile)) dropZone = 'exile';

                        $scope.$applyAsync(function() {
                            if (dropZone === 'hand') {
                                moveCardToZone(draggingCard, 'hand');
                                // Reset position so layoutHand can position it properly
                                draggingCard.left = undefined;
                                draggingCard.top = undefined;
                                c.layoutHand();
                            } else if (dropZone === 'graveyard') {
                                moveCardToZone(draggingCard, 'graveyard');
                                snapToGraveyard(draggingCard);
                            } else if (dropZone === 'exile') {
                                moveCardToZone(draggingCard, 'exile');
                                snapToExile(draggingCard);
                            } else if (dropZone === 'command') {
                                moveCardToZone(draggingCard, 'command');
                                snapToCommand(draggingCard);
                            } else if (dropZone === 'battlefield') {
                                moveCardToZone(draggingCard, 'battlefield', {
                                    x: draggingCard.left,
                                    y: draggingCard.top
                                });
                            } else {
                                moveCardToZone(draggingCard, 'battlefield', {
                                    x: draggingCard.left,
                                    y: draggingCard.top
                                });
                            }
                        });

                        cardEl.style.cursor = 'grab';
                        cardEl.style.transition = '';
                        //draggingCard = null; // Breaks other logic
                        document.onmousemove = null;
                        document.onmouseup = null;
                    };
                });

                cardEl.addEventListener('dblclick', function() {
                    $scope.$applyAsync(function() {
                        if (c.getCardZone(card) === 'battlefield') {
                            card.isTapped = !card.isTapped;
                        }
                    });
                });
            });
        });
        if (!keydownListenerAdded) {
            document.addEventListener('keydown', function(event) {
                const key = event.key.toLowerCase();
                const tag = document.activeElement.tagName.toLowerCase();

                // Don't trigger shortcuts if the user is typing in an input or textarea
                if (tag === 'input' || tag === 'textarea') return;

                $scope.$applyAsync(function() {
                    if (key === 'd') { // Draw card on "D"
                        c.drawCard();
                    } else if (key === 's') { // Shuffle deck on "S"
                        c.shuffleLibrary();
                    }
                });
            });

            keydownListenerAdded = true;
        }

    };

    c.$onInit = function() {
        // Initialize zone arrays from server data
        c.data.commanders = c.data.commanders || [];
        c.data.hand = c.data.hand || [];
        c.data.library = c.data.library || [];
        c.data.battlefield = c.data.battlefield || [];
        c.data.graveyard = c.data.graveyard || [];
        c.data.exile = c.data.exile || [];

        // Combine all cards into a single array for rendering
        c.cards = c.data.commanders.concat(c.data.hand).concat(c.data.battlefield).concat(c.data.graveyard).concat(c.data.exile);

        // Initialize modal state
        c.showModal = false;
        c.modalTitle = '';
        c.modalCards = [];

        $timeout(function() {
            c.renderCards();
        });
    };

    // Show modal for a specific zone
    c.showZoneModal = function(zoneName) {
        var zoneCards;

        if (zoneName === 'command') {
            zoneCards = c.data.commanders;
        } else if (zoneName === 'hand') {
            zoneCards = c.data.hand;
        } else if (zoneName === 'battlefield') {
            zoneCards = c.data.battlefield;
        } else if (zoneName === 'graveyard') {
            zoneCards = c.data.graveyard;
        } else if (zoneName === 'exile') {
            zoneCards = c.data.exile;
        } else {
            zoneCards = [];
        }

        c.currentModalZone = zoneName;

        if (zoneCards.length === 0) {
            c.modalTitle = zoneName.charAt(0).toUpperCase() + zoneName.slice(1) + ' (Empty)';
            c.modalCards = [];
        } else {
            c.modalTitle = zoneName.charAt(0).toUpperCase() + zoneName.slice(1) + ' (' + zoneCards.length + ' cards)';
            c.modalCards = zoneCards;
        }

        c.showModal = true;
    };

    // Hide modal
    c.hideZoneModal = function() {
        c.showModal = false;
        c.modalCards = [];
    };

    // Make getCardZone available to template
    c.getCardZone = getCardZone;

    // Start dragging from modal
    c.startModalDrag = function(event, card) {
        event.preventDefault();
        event.stopPropagation();

        // Set up modal drag state
        c.modalDraggingCard = card;
        c.modalDragOffsetX = event.clientX;
        c.modalDragOffsetY = event.clientY;

        // Create a floating card element for dragging
        var floatingCard = document.createElement('div');
        floatingCard.className = 'floating-modal-card';
        floatingCard.innerHTML = '<img src="' + card.front_image + '" alt="' + card.name + '">';
        floatingCard.style.position = 'fixed';
        floatingCard.style.zIndex = '4000';
        floatingCard.style.pointerEvents = 'none';
        floatingCard.style.width = '181px';
        floatingCard.style.height = '264px';
        floatingCard.style.borderRadius = '6px';
        floatingCard.style.boxShadow = '0 8px 24px rgba(0,0,0,0.6)';

        document.body.appendChild(floatingCard);
        c.floatingCardEl = floatingCard;

    };
};]]></client_script>
        <controller_as>c</controller_as>
        <css>/* Container wrapper */&#13;
.playtester-basic {&#13;
  width: 100%;&#13;
  height: 1000px; /* Increased for larger cards */&#13;
}&#13;
&#13;
/* Playmat grid layout */&#13;
.playmat {&#13;
  display: grid;&#13;
  grid-template-columns: 200px 1fr 200px; /* wider side columns */&#13;
  grid-template-rows: 1fr;&#13;
  gap: 0;&#13;
  width: 100%;&#13;
  height: 88vh;&#13;
  background: cadetblue;&#13;
  border-radius:1%;&#13;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
  user-select: none;&#13;
}&#13;
&#13;
/* Left &amp; Right Columns */&#13;
.left-column, .right-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: flex-start;&#13;
  align-items: center;&#13;
  gap: 20px;&#13;
  padding: 20px 0;&#13;
}&#13;
&#13;
/* Center column zones */&#13;
.center-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: space-between;&#13;
  padding: 20px;&#13;
}&#13;
&#13;
/* Zones shared style */&#13;
.zone {&#13;
  border: 1px dashed white;&#13;
  color: white;&#13;
  text-align: center;&#13;
  font-weight: bold;&#13;
  padding: 4px;&#13;
  box-sizing: border-box;&#13;
}&#13;
&#13;
/* Zone sizes for new card size */&#13;
.library, .graveyard, .exile, .command-zone {&#13;
  width: 181px;&#13;
  height: 264px;&#13;
  position: relative;&#13;
}&#13;
&#13;
.graveyard, .exile {&#13;
  z-index: 10000;&#13;
}&#13;
&#13;
/* Battlefield */&#13;
.battlefield {&#13;
  flex-grow: 1;&#13;
  margin-bottom: 20px;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
}&#13;
&#13;
/* Hand */&#13;
.hand {&#13;
  height: 284px;&#13;
  position: relative; /* helps when computing rects and improves UX */&#13;
  overflow: hidden;   /* visual containment; cards are absolutely positioned on playmat */&#13;
}&#13;
&#13;
/* Command zone styling */&#13;
.command-zone {&#13;
  background: #b03030;&#13;
  border: 1px solid #fff;&#13;
  border-radius: 4px;&#13;
}&#13;
&#13;
/* Health display */&#13;
.health-display {&#13;
  color: #eee;&#13;
  font-size: 18px;&#13;
  text-align: center;&#13;
  user-select: none;&#13;
}&#13;
&#13;
.health-display button {&#13;
  margin: 5px;&#13;
  padding: 6px 12px;&#13;
  font-size: 16px;&#13;
  background: #444;&#13;
  border: none;&#13;
  border-radius: 4px;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
}&#13;
&#13;
.health-display button:hover {&#13;
  background: #666;&#13;
}&#13;
&#13;
/* Draggable cards (scaled up again) */&#13;
.draggable-card {&#13;
  position: absolute;&#13;
  width: 181px;&#13;
  cursor: grab;&#13;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);&#13;
  border-radius: 6px;&#13;
  user-select: none;&#13;
  z-index: 1000;&#13;
  transform-origin: center center;&#13;
  transition: transform 0.2s ease, z-index 0.2s ease, box-shadow 0.2s ease, left 0.3s ease, top 0.3s ease;&#13;
}&#13;
&#13;
.draggable-card img {&#13;
  width: 100%;&#13;
  height: 264px;&#13;
  border-radius: 6px;&#13;
}&#13;
&#13;
.draggable-card.rotated {&#13;
  transform: rotate(90deg);&#13;
}&#13;
&#13;
/* Hand card hover effects - only when actually in hand zone */&#13;
.draggable-card[data-zone="hand"]:hover {&#13;
  z-index: 2000 !important;&#13;
  transform: scale(1.3) !important;&#13;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6) !important;&#13;
}&#13;
&#13;
/* Handle rotated cards in hand */&#13;
.draggable-card[data-zone="hand"].rotated:hover {&#13;
  z-index: 2000 !important;&#13;
  transform: rotate(90deg) scale(1.3) !important;&#13;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6) !important;&#13;
}&#13;
&#13;
/* Ensure cards not in hand don't get hover effects */&#13;
.draggable-card:not([data-zone="hand"]):hover {&#13;
  /* No hover effects for cards outside hand */&#13;
}&#13;
&#13;
/* Library card back (match new size) */&#13;
.zone.library {&#13;
  position: relative;&#13;
  width: 181px;&#13;
  height: 264px;&#13;
}&#13;
&#13;
.library-card-back {&#13;
  position: absolute;&#13;
  top: 50%;&#13;
  left: 50%;&#13;
  width: 181px;&#13;
  height: 264px;&#13;
  transform: translate(-50%, -50%);&#13;
  cursor: pointer;&#13;
  border-radius: 0.6%;&#13;
}&#13;
&#13;
img {&#13;
 border-radius: 0.6rem; &#13;
}&#13;
&#13;
/* Zone Modal Styles */&#13;
.zone-modal {&#13;
  position: fixed;&#13;
  top: 0;&#13;
  left: 0;&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  background: rgba(0, 0, 0, 0.8);&#13;
  z-index: 3000;&#13;
  display: flex;&#13;
  justify-content: center;&#13;
  align-items: center;&#13;
}&#13;
&#13;
.modal-content {&#13;
  background: #2a2a2a;&#13;
  border: 2px solid #444;&#13;
  border-radius: 8px;&#13;
  max-width: 90%;&#13;
  max-height: 90%;&#13;
  width: 800px;&#13;
  height: 600px;&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);&#13;
}&#13;
&#13;
.modal-header {&#13;
  display: flex;&#13;
  justify-content: space-between;&#13;
  align-items: center;&#13;
  padding: 15px 20px;&#13;
  border-bottom: 1px solid #444;&#13;
  background: #333;&#13;
  border-radius: 6px 6px 0 0;&#13;
}&#13;
&#13;
.modal-header h3 {&#13;
  color: white;&#13;
  margin: 0;&#13;
  font-size: 18px;&#13;
}&#13;
&#13;
.close-button {&#13;
  background: none;&#13;
  border: none;&#13;
  color: #ccc;&#13;
  font-size: 24px;&#13;
  cursor: pointer;&#13;
  padding: 0;&#13;
  width: 30px;&#13;
  height: 30px;&#13;
  display: flex;&#13;
  align-items: center;&#13;
  justify-content: center;&#13;
  border-radius: 4px;&#13;
}&#13;
&#13;
.close-button:hover {&#13;
  background: #444;&#13;
  color: white;&#13;
}&#13;
&#13;
.modal-body {&#13;
  flex: 1;&#13;
  padding: 20px;&#13;
  overflow-y: auto;&#13;
}&#13;
&#13;
.zone-cards-grid {&#13;
  display: grid;&#13;
  grid-template-columns: repeat(auto-fill, minmax(181px, 1fr));&#13;
  gap: 15px;&#13;
  position: relative;&#13;
}&#13;
&#13;
.modal-card {&#13;
  width: 181px;&#13;
  height: 264px;&#13;
  cursor: grab;&#13;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);&#13;
  border-radius: 6px;&#13;
  user-select: none;&#13;
  transition: transform 0.2s ease, box-shadow 0.2s ease;&#13;
  position: relative;&#13;
}&#13;
&#13;
.modal-card:hover {&#13;
  transform: scale(1.05);&#13;
  box-shadow: 0 6px 20px rgba(0,0,0,0.6);&#13;
  z-index: 10;&#13;
}&#13;
&#13;
.modal-card img {&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  border-radius: 6px;&#13;
  object-fit: cover;&#13;
}&#13;
&#13;
.modal-card.rotated {&#13;
  transform: rotate(90deg);&#13;
}&#13;
&#13;
.modal-card.rotated:hover {&#13;
  transform: rotate(90deg) scale(1.05);&#13;
}&#13;
&#13;
/* Floating modal card during drag */&#13;
.floating-modal-card {&#13;
  pointer-events: none;&#13;
  z-index: 4000;&#13;
}&#13;
&#13;
.floating-modal-card img {&#13;
  width: 100%;&#13;
  height: 100%;&#13;
  border-radius: 6px;&#13;
  object-fit: cover;&#13;
}&#13;
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>mtg_playtest</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck Playtest</name>
        <option_schema>[{"name":"deck_sys_id","section":"other","default_value":"d81646edc38326100efafbfdd401318f","label":"Deck Sys ID","type":"string"}]</option_schema>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
    var deckId = options.deck_sys_id || input.deck_sys_id;

    // Default fallback
    data.playerHealth = 20;

    // Load deck record
    var deckGR = new GlideRecord('x_759224_magic_c_0_mtg_deck');
    if (deckGR.get(deckId)) {
        var formatSysId = deckGR.getValue('format');

        // Load related format record
        var formatGR = new GlideRecord('x_759224_magic_c_0_deck_formats');
        if (formatGR.get(formatSysId)) {
            var hp = parseInt(formatGR.getValue('starting_hp'), 10);
            if (!isNaN(hp)) {
                data.playerHealth = hp;
            }
        }
    }

    data.commanders = [];
    data.hand = [];
    data.library = [];

    if (!deckId) {
        data.error = "No deck_sys_id provided.";
        return;
    }

    var utils = new x_759224_magic_c_0.magic_utils();

    var deckCardGR = new GlideRecord('x_759224_magic_c_0_deck_card');
    deckCardGR.addQuery('deck', deckId);
    deckCardGR.query();

    var commanders = [];
    var nonCommanders = [];

    // Loop through each of the deck card records
    while (deckCardGR.next()) {
        // Get quantity so we add
        var quantity = parseInt(deckCardGR.getValue('quantity'), 10) || 1;
        var isCommander = deckCardGR.is_commander.toString() === 'true';
        var isSideboard = deckCardGR.is_sideboard.toString() === 'true';
        var isMaybeboard = deckCardGR.is_maybeboard.toString() === 'true';
        // If the card exists and is not sideboard nor maybeboard
        var cardGR = new GlideRecord('x_759224_magic_c_0_mtg_cards');
        if (cardGR.get(deckCardGR.getValue('card')) && !isSideboard && !isMaybeboard) {
            var cardData = {
                sys_id: cardGR.getUniqueValue(),
                name: cardGR.getValue('name'),
                front_image: utils.getImgSrc(cardGR.getValue('front_image')),
                back_image: utils.getImgSrc(cardGR.getValue('back_image')),
                is_commander: isCommander,
                notes: deckCardGR.getValue('notes')

            };

            var targetArray = cardData.is_commander ? commanders : nonCommanders;
            for (var i = 0; i < quantity; i++) {
                targetArray.push(Object.assign({}, cardData));
            }
        }
    }

    // Shuffle non-commander cards
    function shuffle(array) {
        var currentIndex = array.length,
            randomIndex;

        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;

            var temp = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temp;
        }

        return array;
    }

    shuffle(nonCommanders);

    data.hand = nonCommanders.slice(0, 7);
    data.library = nonCommanders.slice(7);
    data.commanders = commanders;
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>greg</sys_created_by>
        <sys_created_on>2023-10-05 04:26:39</sys_created_on>
        <sys_id>b4bd4bbb972d3d1078cb33121153afcd</sys_id>
        <sys_mod_count>135</sys_mod_count>
        <sys_name>MTG Deck Playtest</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_b4bd4bbb972d3d1078cb33121153afcd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-08-10 05:16:54</sys_updated_on>
        <template><![CDATA[<div class="playtester-basic">
  <div class="playmat">
    <!-- Left Column -->
    <div class="left-column">
      <div class="zone library" ng-click="c.drawCard()">
        <img ng-if="c.data.library.length > 0"
             src="https://backs.scryfall.io/normal/2/2/222b7a3b-2321-4d4c-af19-19338b134971.jpg?1677416389"
             alt="Library Card Back"
             class="library-card-back" />
      </div>
      <div class="zone graveyard" ng-click="c.showZoneModal('graveyard')">Graveyard</div>
      <div class="zone exile" ng-click="c.showZoneModal('exile')">Exile</div>
    </div>

    <!-- Center Column -->
    <div class="center-column">
      <div class="zone battlefield">Battlefield</div>
      <div class="zone hand">Hand</div>
    </div>

    <!-- Right Column -->
    <div class="right-column">
      <div class="zone command-zone" ng-click="c.showZoneModal('command')">Command Zone</div>
      <div class="health-display">
        <div class="player-health">Health: {{c.playerHealth}}</div>
        <button ng-click="c.modifyHealth(-1)">-1</button>
        <button ng-click="c.modifyHealth(1)">+1</button>
      </div>
    </div>

    <!-- Draggable Cards -->
    <div class="draggable-card"
         ng-repeat="card in c.cards"
         ng-class="{'rotated': card.isTapped, 'hand-card': c.getCardZone(card) === 'hand'}"
         ng-attr-data-zone="{{c.getCardZone(card)}}"
         ng-style="{'left': card.left + 'px', 'top': card.top + 'px'}">
      <img ng-src="{{card.front_image}}" alt="{{card.name}}">
    </div>
  </div>

  <!-- Zone Modal -->
  <div class="zone-modal" ng-if="c.showModal" ng-click="c.hideZoneModal()">
    <div class="modal-content" ng-click="$event.stopPropagation()">
      <div class="modal-header">
        <h3>{{c.modalTitle}}</h3>
        <button class="close-button" ng-click="c.hideZoneModal()">×</button>
      </div>
      <div class="modal-body">
        <div class="zone-cards-grid">
          <div class="modal-card"
               ng-repeat="card in c.modalCards"
               ng-class="{'rotated': card.isTapped}"
               ng-mousedown="c.startModalDrag($event, card)">
            <img ng-src="{{card.front_image}}" alt="{{card.name}}">
          </div>
        </div>
      </div>
    </div>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
