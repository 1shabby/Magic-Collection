<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[api.controller = function($scope, $element, $timeout) {
    var c = this;

    c.playerHealth = c.data.playerHealth || 20;
    c.cards = []; // Holds all draggable cards (commanders + hand)

    var draggingCard = null;
    var offsetX = 0,
        offsetY = 0;

    c.modifyHealth = function(amount) {
        $scope.$applyAsync(function() {
            c.playerHealth = Math.max(0, c.playerHealth + amount);
        });
    };

	// Method to draw cards from the top of the library.
    c.drawCard = function() {
        if (c.data.library.length === 0) return;

        var drawnCard = c.data.library.shift();

        // Reset position for new card (will be assigned in renderCards)
        drawnCard.left = undefined;
        drawnCard.top = undefined;

        c.data.hand.push(drawnCard);
        c.cards.push(drawnCard);

        c.renderCards();
    };

    c.renderCards = function() {
        var playmatEl = $element[0];
        var handZone = playmatEl.querySelector('.hand');
        var commandZone = playmatEl.querySelector('.command-zone');
        var playmatRect = playmatEl.getBoundingClientRect();

        var cardWidth = 181;
        var cardHeight = 264;

        var gapX = 10;

        // Initialize position for cards without set coords
        c.cards.forEach(function(card, index) {
            if (card.left === undefined || card.top === undefined) {
                if (card.is_commander) { // If card is commander, put it in command zone
                    var zoneRect = commandZone.getBoundingClientRect();
                    var zoneLeft = zoneRect.left - playmatRect.left;
                    var zoneTop = zoneRect.top - playmatRect.top;

                    // Perfectly center the card within the zone
                    card.left = Math.round(zoneLeft + (zoneRect.width - cardWidth) / 2);
                    card.top = Math.round(zoneTop + (zoneRect.height - cardHeight) / 2);
                } else { // Put card into hand
                    card.left = handZone.getBoundingClientRect().left - playmatRect.left + 10 + index * (cardWidth + gapX);
                    card.top = handZone.getBoundingClientRect().bottom - playmatRect.top - cardHeight - 10;
                }
            }
			// initialize tapped state
            if (card.isTapped === undefined) card.isTapped = false; 
        });

        $timeout(function() {
            var cardsEls = playmatEl.querySelectorAll('.draggable-card');

            cardsEls.forEach(function(cardEl, i) {
                cardEl.style.position = 'absolute';

                var card = c.cards[i];
                if (!card) return;

                cardEl.style.left = card.left + 'px';
                cardEl.style.top = card.top + 'px';

                // Visual tapped effect toggle (example: rotate card)
                if (card.isTapped) {
                    cardEl.classList.add('rotated');
                } else {
                    cardEl.classList.remove('rotated');
                }

                // Clean old handlers
                cardEl.onmousedown = null;
                cardEl.onmouseup = null;
                cardEl.ondblclick = null;
                document.onmousemove = null;

                cardEl.addEventListener('mousedown', function(e) {
                    draggingCard = card;
                    offsetX = e.clientX - card.left;
                    offsetY = e.clientY - card.top;
                    cardEl.style.cursor = 'grabbing';
                    cardEl.style.transition = 'none';
                    e.preventDefault();

                    document.onmousemove = function(e) {
                        if (!draggingCard) return;
                        draggingCard.left = e.clientX - offsetX;
                        draggingCard.top = e.clientY - offsetY;

                        cardEl.style.left = draggingCard.left + 'px';
                        cardEl.style.top = draggingCard.top + 'px';
                    };

                    document.onmouseup = function() {
                        if (!draggingCard) return;
                        cardEl.style.cursor = 'grab';
                        cardEl.style.transition = '';
                        draggingCard = null;
                        document.onmousemove = null;
                        document.onmouseup = null;
                    };
                });

                cardEl.addEventListener('dblclick', function() {
                    $scope.$applyAsync(function() {
                        card.isTapped = !card.isTapped;
                    });
                });
            });
        });
    };

    c.$onInit = function() {
        // Combine commanders and hand into cards array for rendering & dragging
        c.cards = (c.data.commanders || []).concat(c.data.hand || []);

        $timeout(function() {
            c.renderCards();
        });
    };
};]]></client_script>
        <controller_as>c</controller_as>
        <css>/* Container wrapper */&#13;
.playtester-basic {&#13;
  width: 100%;&#13;
  height: 1000px; /* Increased for larger cards */&#13;
}&#13;
&#13;
/* Playmat grid layout */&#13;
.playmat {&#13;
  display: grid;&#13;
  grid-template-columns: 200px 1fr 200px; /* wider side columns */&#13;
  grid-template-rows: 1fr;&#13;
  gap: 0;&#13;
  width: 100%;&#13;
  height: 88vh;&#13;
  background: black;&#13;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
  user-select: none;&#13;
}&#13;
&#13;
/* Left &amp; Right Columns */&#13;
.left-column, .right-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: flex-start;&#13;
  align-items: center;&#13;
  gap: 20px;&#13;
  padding: 20px 0;&#13;
}&#13;
&#13;
/* Center column zones */&#13;
.center-column {&#13;
  display: flex;&#13;
  flex-direction: column;&#13;
  justify-content: space-between;&#13;
  padding: 20px;&#13;
}&#13;
&#13;
/* Zones shared style */&#13;
.zone {&#13;
  border: 1px dashed white;&#13;
  color: white;&#13;
  text-align: center;&#13;
  font-weight: bold;&#13;
  padding: 4px;&#13;
  box-sizing: border-box;&#13;
}&#13;
&#13;
/* Zone sizes for new card size */&#13;
.library, .graveyard, .exile, .command-zone {&#13;
  width: 181px;&#13;
  height: 264px;&#13;
}&#13;
&#13;
/* Battlefield */&#13;
.battlefield {&#13;
  flex-grow: 1;&#13;
  margin-bottom: 20px;&#13;
  position: relative;&#13;
  overflow: hidden;&#13;
}&#13;
&#13;
/* Hand */&#13;
.hand {&#13;
  height: 284px; /* fits new card height + spacing */&#13;
}&#13;
&#13;
/* Command zone styling */&#13;
.command-zone {&#13;
  background: #b03030;&#13;
  border: 1px solid #fff;&#13;
  border-radius: 4px;&#13;
}&#13;
&#13;
/* Health display */&#13;
.health-display {&#13;
  color: #eee;&#13;
  font-size: 18px;&#13;
  text-align: center;&#13;
  user-select: none;&#13;
}&#13;
&#13;
.health-display button {&#13;
  margin: 5px;&#13;
  padding: 6px 12px;&#13;
  font-size: 16px;&#13;
  background: #444;&#13;
  border: none;&#13;
  border-radius: 4px;&#13;
  color: white;&#13;
  cursor: pointer;&#13;
}&#13;
&#13;
.health-display button:hover {&#13;
  background: #666;&#13;
}&#13;
&#13;
/* Draggable cards (scaled up again) */&#13;
.draggable-card {&#13;
  position: absolute;&#13;
  width: 181px;&#13;
  cursor: grab;&#13;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);&#13;
  border-radius: 6px;&#13;
  user-select: none;&#13;
  z-index: 1000;&#13;
  transform-origin: center center;&#13;
  transition: transform 0.2s ease;&#13;
}&#13;
&#13;
.draggable-card img {&#13;
  width: 100%;&#13;
  height: 264px;&#13;
  border-radius: 6px;&#13;
}&#13;
&#13;
.draggable-card.rotated {&#13;
  transform: rotate(90deg);&#13;
}&#13;
&#13;
/* Library card back (match new size) */&#13;
.zone.library {&#13;
  position: relative;&#13;
  width: 181px;&#13;
  height: 264px;&#13;
}&#13;
&#13;
.library-card-back {&#13;
  position: absolute;&#13;
  top: 50%;&#13;
  left: 50%;&#13;
  width: 181px;&#13;
  height: 264px;&#13;
  transform: translate(-50%, -50%);&#13;
  cursor: pointer;&#13;
  border-radius: 0.6%;&#13;
}&#13;
&#13;
img {&#13;
 border-radius: 0.6rem; &#13;
}&#13;
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>mtg_drag</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {
  
}]]></link>
        <name>MTG Deck Playtest</name>
        <option_schema>[{"name":"deck_sys_id","section":"other","default_value":"d81646edc38326100efafbfdd401318f","label":"Deck Sys ID","type":"string"}]</option_schema>
        <public>true</public>
        <roles/>
        <script><![CDATA[(function() {
    var deckId = options.deck_sys_id || input.deck_sys_id;

    // Default fallback
    data.playerHealth = 20;

    // Load deck record
    var deckGR = new GlideRecord('x_759224_magic_c_0_mtg_deck');
    if (deckGR.get(deckId)) {
        var formatSysId = deckGR.getValue('format');

        // Load related format record
        var formatGR = new GlideRecord('x_759224_magic_c_0_deck_formats');
        if (formatGR.get(formatSysId)) {
            var hp = parseInt(formatGR.getValue('starting_hp'), 10);
            if (!isNaN(hp)) {
                data.playerHealth = hp;
            }
        }
    }

    data.commanders = [];
    data.hand = [];
    data.library = [];

    if (!deckId) {
        data.error = "No deck_sys_id provided.";
        return;
    }

    var utils = new x_759224_magic_c_0.magic_utils();

    var deckCardGR = new GlideRecord('x_759224_magic_c_0_deck_card');
    deckCardGR.addQuery('deck', deckId);
    deckCardGR.query();

    var commanders = [];
    var nonCommanders = [];

    // Loop through each of the deck card records
    while (deckCardGR.next()) {
        // Get quantity so we add
        var quantity = parseInt(deckCardGR.getValue('quantity'), 10) || 1;
        var isCommander = deckCardGR.is_commander.toString() === 'true';
        var isSideboard = deckCardGR.is_sideboard.toString() === 'true';
        var isMaybeboard = deckCardGR.is_maybeboard.toString() === 'true';
        // If the card exists and is not sideboard nor maybeboard
        var cardGR = new GlideRecord('x_759224_magic_c_0_mtg_cards');
        if (cardGR.get(deckCardGR.getValue('card')) && !isSideboard && !isMaybeboard) {
            var cardData = {
                sys_id: cardGR.getUniqueValue(),
                name: cardGR.getValue('name'),
                front_image: utils.getImgSrc(cardGR.getValue('front_image')),
                back_image: utils.getImgSrc(cardGR.getValue('back_image')),
                is_commander: isCommander,
                notes: deckCardGR.getValue('notes')

            };

            var targetArray = cardData.is_commander ? commanders : nonCommanders;
            for (var i = 0; i < quantity; i++) {
                targetArray.push(Object.assign({}, cardData));
            }
        }
    }

    // Shuffle non-commander cards
    function shuffle(array) {
        var currentIndex = array.length,
            randomIndex;

        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;

            var temp = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temp;
        }

        return array;
    }

    shuffle(nonCommanders);

    data.hand = nonCommanders.slice(0, 7);
    data.library = nonCommanders.slice(7);
    data.commanders = commanders;
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>greg</sys_created_by>
        <sys_created_on>2023-10-05 04:26:39</sys_created_on>
        <sys_id>b4bd4bbb972d3d1078cb33121153afcd</sys_id>
        <sys_mod_count>93</sys_mod_count>
        <sys_name>MTG Deck Playtest</sys_name>
        <sys_package display_value="Magic Collection" source="x_759224_magic_c_0">c09f498f9741a1107720f0571153afe1</sys_package>
        <sys_policy/>
        <sys_scope display_value="Magic Collection">c09f498f9741a1107720f0571153afe1</sys_scope>
        <sys_update_name>sp_widget_b4bd4bbb972d3d1078cb33121153afcd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-08-09 17:42:43</sys_updated_on>
        <template><![CDATA[<div class="playtester-basic">
  <div class="playmat">
    <!-- Left Column -->
    <div class="left-column">
      <div class="zone library" ng-click="c.drawCard()">
        <img ng-if="c.data.library.length > 0"
             src="https://backs.scryfall.io/normal/2/2/222b7a3b-2321-4d4c-af19-19338b134971.jpg?1677416389"
             alt="Library Card Back"
             class="library-card-back" />
      </div>
      <div class="zone graveyard">Graveyard</div>
      <div class="zone exile">Exile</div>
    </div>

    <!-- Center Column -->
    <div class="center-column">
      <div class="zone battlefield">Battlefield</div>
      <div class="zone hand">Hand</div>
    </div>

    <!-- Right Column -->
    <div class="right-column">
      <div class="zone command-zone">Command Zone</div>
      <div class="health-display">
        <div class="player-health">Health: {{c.playerHealth}}</div>
        <button ng-click="c.modifyHealth(-1)">-1</button>
        <button ng-click="c.modifyHealth(1)">+1</button>
      </div>
    </div>

    <!-- Draggable Cards -->
    <div class="draggable-card"
         ng-repeat="card in c.cards"
         ng-class="{'rotated': card.isTapped}"
         style="left: {{card.left}}px; top: {{card.top}}px;">
      <img ng-src="{{card.front_image}}" alt="{{card.name}}">
    </div>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
